<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Hook学习]]></title>
    <url>%2F2019%2F11%2F18%2FreactHooks%2F</url>
    <content type="text"><![CDATA[Hooks 在React 16.8以上的版本中才可以使用 Hook 定义 Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 Hook 使用了 JavaScript 的闭包机制React 并不会放弃 classClass 的缺陷： this 的指向问题，在函数组件的编写中经常会碰到this的指向问题 编译过后的代码大小 Javascript实现的类本身比较鸡肋，没有类似Java/C++多继承的概念，类的逻辑复用是个问题 Class Component在React内部是当做Javascript Function类来处理的 Hook 使用规则 Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 只能在 React 的函数组件或者自定义的Hook中调用 Hook。 使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。 在实际编写底层组件库中常常会配合 useState Hook 进行测试, 因为我们的最底层的组件通常应该是被设计成 stateless 的，需要外部传入props 进行控制测试 相关 Hook 的使用useState Hook 在函数组件中、通过 useState Hook 可以使用在class中的 state 特性；返回一个状态以及这个状态的 setter 方法。 useEffect Hook 在每次渲染后都会调用 useEffect 中的函数,它让我们在函数组件中存储内部 state 在文档中 被翻译成副作用（感觉即将废弃的那几个生命周期才更应该是称得上“副作用”），即我们原来在 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 中做得获取数据、销毁操作都被认为是 与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快(effect 是异步的操作)。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。 与useState传入的是具体state不同，useEffect传入的是一个callback函数，与useState最大的不同是执行时机，useEffect callback是在组件被渲染为真实DOM后执行（所以可以用于DOM操作） Demo01 Test -&gt; useState Hook useEffect Hook 123456789101112131415161718192021import React, &#123; useState, useEffect &#125; from 'react';const Example = () =&gt; &#123; const [count, setCount] = useState(0); // 相当于 componentDidMount 和 componentDidUpdate: // 在执行 DOM 更新之后调用 useEffect(() =&gt; &#123; // 在render后输出点击的次数 console.log(`You clicked $&#123;count&#125; times`); &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; CLICK CRAZY! &lt;/button&gt; &lt;/div&gt; );&#125; 副作用函数还可以通过返回一个函数来指定如何“清除”副作用。 当在 useEffect 中 返回一个函数的话，这个函数相当于原先 class组件中的 componentWillUnmount 的时候调用 123456789101112131415161718192021222324import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // 可以添加第二个参数、只要第二个参数发生变化、return中的方法也会执行 useEffect(() =&gt; &#123; console.log(`You clicked $&#123;count&#125; times`); // 相当于 unmount return () =&gt; &#123; console.log('Bye...'); &#125; // 如果传入 第二个参数 监听某个state变化而执行、实现性能优化，在监听的元素发生变化后才调用 effect &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useContext HookuseContext 的参数必须是 context 对象本身 useCallback HookuseRef React Hooks 文档 React Hooks 完全上手指南]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待办事项]]></title>
    <url>%2F2019%2F11%2F15%2FTODOs%2F</url>
    <content type="text"><![CDATA[技术胖 Rect Hook 实战 Nginx]]></content>
  </entry>
  <entry>
    <title><![CDATA[Iterm2 相关]]></title>
    <url>%2F2019%2F11%2F13%2Fiterm2%2F</url>
    <content type="text"><![CDATA[command + D / command + shift + D 分屏 快捷键参考 发病期有3-5天、不管怎么治疗，吃不吃药都会恶化，所以前期还是要有一个好的心态。 避免面部吹风、准备口罩围巾啥的裹好一点，骑车漏风的话就打车吧 多给脸部按摩 保持积极的心态、保证休息时间 补充营养、维生素b1、甲钴胺（这个具体得问医生了） 复诊的时候问清楚医生这个能不能针灸以及针灸有没有用，有用的话可以看看中医，中西结合治疗。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Homebrew 的使用]]></title>
    <url>%2F2019%2F11%2F12%2FhomeBrew%2F</url>
    <content type="text"><![CDATA[Homebrew： 家酿 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[不在node 中处理管理前端资源]]></title>
    <url>%2F2019%2F11%2F12%2FstaticFiles%2F</url>
    <content type="text"><![CDATA[nodebestpractice资源]]></content>
      <categories>
        <category>Node最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[委托可能的一切]]></title>
    <url>%2F2019%2F11%2F12%2Femm%2F</url>
    <content type="text"><![CDATA[委托任何可能的 (例如静态内容，gzip) 到反向代理 argTeam]]></content>
      <categories>
        <category>Node最佳实践</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[九、十月复盘]]></title>
    <url>%2F2019%2F11%2F06%2F20191106%2F</url>
    <content type="text"><![CDATA[加密文章，可能是个人情感宣泄或者生活记录。 91868fe92bac4993c4028cc40da992adc432c7c6933ab1489a8014e35f893b4601f85fc6aa3c85c751ffbc8067b3cf0307bb0922656e3b19b40a7c667d5faebba36c11b03f916c60fab89b6a195487751951cf6632efa3245c958cb8a6fff60f2a3db1eb6bf3a2da2e3461087451d39cc468d4b625460e7296b74dd5c8520c3a1e8632bbda0dd3d331d9445ac2863f78c47d91fd643a353d22157ff9c2557eaad2896bf3ec18f9c05f0bdb8dc3240f1c0aac061108a9f0ccf21a4d06f6a167e04966a22b3afa45a021d90e17015e03d5a50f2742725709975584a06d93624803459db411a30c760216f3f327e863772ca03a5c5c2c09ec386120914b7d7cc233e061bba8b1f56c043935af962efdcdacdf04018547890d949a8d50fcdec8b5c18f5f3300428a2ccfb9456752d43910943c9e136136842459f422528027eee61a45f4ddb801821628c5cda144e509646a4c1c53e0d5c90d789ad2c02ae38d7651300fce9dff64564cdfe8f750aed619cd66946e0ca82860e8d2ef75d473ae6c97fcb8061a8bc97118c2b530fdaf507add968bf1b0646fbdc40ba68240adfcef0213af3580a1ddc3cf41d2ca7198bf8ed60ff42cd26f95979162bdae16f125adc093e0fedd0bf63542342b1eac0a80febc0887ff7c2a2f5960c04947b7e102db31b41584caa2d2001703e554867fc6f539c31399d4e532a17209a156a7827583b599ef7297eb9879090d292a40d57d5bc14ec45fddc435b21218fdb2d7266b4e7d5bb56a8073c7c29e68a73158d76d223a00efdd42e82500dbe4a0a52b77da377b39606a9e52e575053eba0d30457cffbdaa03acb72d65b2c5b95c54337a33ddb5a35b4542b8612303a033a7eb49104751382dbb8674a3d7a9a6bbf44630d78632df2f1cab561c019b2bc3d6e88b7464e8fea01926160e85b58a3a5c99784064b733c6fb408f54af00ab90c99dbaf3fee756e21d882580d604ba5d8122764c004a8425b4b7b53028f164a1c9a23c2eafc8ee1427c38db4ef520edee57042ddc4fd7b891f1e5d155b080c4c8cacff929f39c73a1b6ba71f8a03d0ff2c6f30c5a7558e0769d63e62c2444edc5c25452ece9b4376182ab7dd6144dafc45e19859123371133b8de2a1980cb29bb393b852a6e0d4ab54bec7ea2cb14752c24f8d1b56bd9a5bd0699e75a94327cb6842308cef801c4238cafc6fe6e1183bc18434aac14cf7e560b6a345acbe3cb0f10399696366295ea999141b340489d6e8b3feef541e8534c6611afad90523db144acac3aab0bde873b04a8c8e6bf255d526af9e9c1833f9eb397f0406ac2725db327794ce14eb6a8ed51bfedb4ddce60583e3ebf04a4afd123d161c43254b0a843ac79351cbe66c93db8037fa08d0ec351af5a88a68f7c8e6c70c9220d0c666f6f11b2d4775597d7f4e3796284b02f05b08dec244f188d0f254c5efed23542c46eeba9bce6db95ce3163e464c371952646884d5aaa480988a735f520caa6f7d9b8a8bf56132f7587f7021582dbeba1febc79c19b41d90e92c5199e5ad50ce2596968590bd00fa17ec37d5273c56d927e0d7e34b65a37179046df075a56177aeaffa1bd1f46b2a2cb912ecb03568928d889fd3a9c1124ec497bcf4ed2bb2324c79c1102734c865ded8d2e5af3d43a162a8fbd331dfb1cdd8b21bd6477d1ed9d70afe4131cf1919295830bacfb6a6ac329be07644d6543f8f0279671b4b80d70541e1fa3d26a0b9c120c4599ba14d083c4f08891a8672f343a9b53cc432e3f6ed81d9cba6b2b87176b4b310371ead4dd7b70a713de14210865c3341376ea98f95614465f40182bd52db24cd7815ddbd2a306d384c3b43371008b09f85de698036928375bdc0b2057354057f7a7e0309bdef14ac6c7fb830bb06d4824a311d0b3ca7231a66f8c6ec0b1c3898ee61a224f2bd2b6b77598abff86acf5d74c3d586b0aca06174ad70db302f0569fefb80b5e2be21a8c5583d8b2b688148ed22d1962756d791cc25f39fbde2f2fe8bb9713babce5e0d7544eb0ac73577f99e17100adfeb0d12607a7b688b6ed3921329b2d81d72b57668079f81f78421ff9d1d3cc1acbc772598a369f40848b723cd57b720cc3d88f363efa61a900129d2d03503f350b2453a113da7f90c6ab59c891e696816733da84857aeaef98cb631967f086cb9161ce6b4a647ac96dc3811aa83983cdec275dff9495d865f84b1c3f15c8767044727f32fe61a095051dc066b86e30fc683ba99eb6f6ee735bbe59c025b592106290d8a65c26cc671cab7c825c26360a18fc778b780b8d9ba4e7c0cb57cbf2724a312bd5575609dac2bcf59ebb88fadd0366c73535fb434eacb19aa4d99595b20803e269f20277d67f993b7e41bff33b639bfbb79823e6c9f520073fe0515f10e0a3dfd496a87c0b42d69da2367cee0adca5c6e73e74eb31aa477e64b90ba1a46afb197a1613ddeb4e36d995748b67aa83ef6917a55f9d4c2b7528b58c41604fc8d398a1df0d92f9de892d75c04e810fd496f1c924fe29921095b6957916209709a7b1a62ca1d6d8f533562f8609b34ecc695334b629c4db4ed38359d5c9407015664b11f8f5c95317bc53d33fa45c03a0a90cfae82913476169bddfa4ae3d7490c0617dd35515785c88c2c94048dc8b31f9bb26d9c600f8a55a2f30f86bd0efa20f1dd5358d7bf03b8724a803b01acc1427568eed0a334e0438ed9e012af0bdc0e1635300e804b7b1ceb06cbc73bb105ffd0ab2d19badff5757bb4b2638ba3ef907cfb8111e967095661ca6a6850dcfbd884d97a267d22ea82dc1ee4d85edc26f88b3950785dd8295f1389073156929d4058bd5abfaf123ad46e9d63ff7d2026ed8fc241f00fc3c644d6df233bb9684533def99db872e22ba89877c148c3d87ac283fb61f886f7b008f1b4a485dc480d8bb2cb75e7c1c25e758a9f1db0913a329b02d98322c9b0d97e5f74f1dd2f1f12f1e1c6f514e1a1a0a4ccd3ca8d0b2c5b3dd90f261966e1c473c7ddedfc5ead1ddd9035775cfa58ba462de1f8faec7c3602013c987c55837a6f185fff97e16773122ab347f1803b1dc5bd7fa8d8ccfad9d424de135bdcd27b076234e74c84f9c26ffa94103ba9cd11b40fd6edb9910bfd59dbdddefc48e548a0fba6c1e12fc45fe4f7a1a883c4ebd8989daecffd72a77c4330293825ab1860a596c62bb47aa56675921256f235449908e92715f5fa514276a545d2c936136c68d00a1cf6d3e2fb26024fb4594064394dc55a4649f1eac7be4c12cf006f181fec510df656d21bcbff77a1ac8805b2294b706b852156a33b0347d212361443c4be882903232dc2e8dd8e6e12c0566867d60a21f8565fddccd041d2a2db79dd3ab7cf1cf1e697a150f50ec5582875649483eb04843ada70cde2831a6c4a8442f82cf6f2655b664162d8c51dbc90e4c718743ccf2687afa45a2846abcd6894a46608f80b7f579bad3a8a323464a940bb805ad25808b02d633234774d29729f28cc4e1942e68bead7219996e8e5083799a51f99f56c93b50c79c018ffcb510c828d6d72d4802381b7551fd0804de650030faab57f80a3b302047c3b2d733d4c4af360b5897221b7efe68085c1bdf43a907b3c18480d5f1c640670bd249443189921db62a80a7cad011fd5309e21ae1709911648deb6292ed257cbfac4f77853837c570fbd48663644221aba1c6c65861d9de25a6f1d2e641030b2a7f04ffdf627cf1653b258d2a75499b75ec523060a50fbb26546eff78c3ed21d62d8f9465609de9d36d38975db0234c028f356430671e39da4fac2ba33c6660b94acb5dd1a741b00f4f818d02b9581ee6212a51a38bcdab6f99d10cbb263ae06cd50dc24c74ab77380bddd883ff2c7d865f12186972d443e2eda28ffa049ab9fa72bea9d5abe5560338db6cab80797ef3f07220adf46dc78a7c7ce02e019cfaa2e2d7a5942f3369cc4524479b680719784d629114bad40f46644e3eef0d87e8abb5ddd8a70cfd0e20b0035893d013ecdcbb80678e8192267e21d7fda9e643ea1d7e7ad73b47db9325c0aa60deddf1c345eab6d3820471a9e9c8c149659755ae684bf815eb03880342a1b15a673a1ac71632389d45c6cf4daade2a256e19f1cf44c651a91fa14ec73d192a7389a75deab97d2d8b1b530c945e9930f75b6a0693cdd1af5bd7ec1adfd96f84130565c880fb85c6fc1387cece9b4289b7f922e8416100163f3c8f66616942cbcd3e9d049bedba7b0f9c47c22e6db4360616c1450443ad9338295b62efb9c805debc24f5616e829f4da2446f95e2b9f0ac9bf67b372fad9eb2f0ebe25157634e46bc7e575be334bd58e028cf4b7eb67a5c18854dc254d6794b054002c9b7a244b9b257139e2684d799a83edd2d4c3c6b845314b5aee462b79aae997f410efaf3410a64e0c0a443ae563d22ed186bd022f6ba7cf834c5a125f6c08fe23d25ec5874f48ad12dfd54864ce588aceb8b7edaaf22e1c765dead6cbd433dc5af83c6b2f1f65831cec119f059cacd7b952fcabc2766910e4e0a805ed66cdab926c1d8ef50ebb05b072f091bffc8b2937d6031de4f6ac1c96251aa2e2a79a97a57aae3ea7e1c9b5541606a5275f4d96716c4e8dfa47260f25dce6e572743c220e8a3d738cebe010ae91f64fdf20450f476708f290368915f8470681d8a10539262b6628c291151bc67d8b468c07822a98d1c47ffd74485109b180fa2d0671c9a91e71d6504da78e05a5b0ded9d20ef5e976f663f2a2c1c69f4e931489b07b17926ada7fe429f56892bc8b8c25bea63f54d3fd3f991cc18ad731899db7382305f6b83171e2d75d9b4558aefe71a31c066827e7bf58aee267fbee6c20eeb53670a5d29a23f5eb9d6daa08d7330298d85a9995fb3a352151fc8924324a10a23fa24b66c79cd93da73e46df10eb2e03296264cc98baab247177d45b383df62bf31125e4ff98714150606922378eba00451b919d12e4795413ff14d013488940fc9a503f67eec1b7a3c8e2d83a902df4c49790139806ad841e62e9b3daae9cd448dbe0219d106d4e2891b63bf091e8987a6d640dee42faafe6e672b66a5bcfae079bca416ec33db9ac6b4d55034776be90de64eb0c727050134b78c3749222e3bcc4fcda97c078775dd2c3f1de05406a872d08b2e2450e1922a12e36750d53d6ef365a8e316289a7badcecaa0ca781da4a71179656ef1055b88ba4e053f3243e7c8599c8a02ef7fbcf0ff5b603db7c916783ab061ce4a2603400915fd8f032d7e78a89640374979ff06714e90e30557f4d002eba9c9b8456c01e0b9d865142bf5714ca7dfa22ac6974722b4854880b90f27a01f5fa63752cf4eb0e38ea584a9756b786913ec2e0d2626a51257507e254425efc28b99d1805b9528ef70848bf37d58b18243b19a9cb9e846b5ed08be171ef2ece902977e8236149f725003f69eb1772f9385346f5f4a90f47c2c74d7b928700fc35065b624000b4d4dd8121e0e851433198cca9173f65892f06fa7c430039f8f561416d04ca35cb7cb37d42c5488048075ad45a15ca81f51d5b8974658fb2c316f3b48ccae77d5de98ee2b10e012d944825c302130a0d46158ffbe768d7dd5ca1e9b05a758dc58f88a00e4d1f7f7dfbbb2ec3436d00dcc8cf8b7ca9be6e463dce35f09df01434453bf80a4bfb0b54653369daa8ee8b6404bbef118dc28374ef88ffedceb7f0403692f730c73b376b5e5304521a63b7f7b634e8860e5326425f18a463ea5500d136693a62b6d202689cf7d58ad07f4be53bd80f7d2bcaac9db5c7549354c0b545bcc166d06a2c474dc852c00622276557295e28eb802b38682327243082e6a213018c5b5728dd03145b298946ad7dca602d498e0810cd0a789812276215e1e3d0452c7696a85dda8aba1eb91cd4295f91867a398bd2341b174b3f8310ab3a9d1aa00d2a2375c15e58d952605d7f27cae077f6539993c09d3f0708598a77379f6a4da13bb928dd53f0dafcd5c2fd2adbc84844f06b52325dae7fedc45d7872ea6c1fede52eb38dd7bbadbf8068f299f53c411d76860739cf23ace94fade02a95ab7558fd885b05b3cff1c64db350119fc24bc09a4e1551dcaafde06d96aa396cce244fd769edd8f91426ea5250318aca7d7a6f9ad7dc4d43a7394f236b8c200a9e133fa04eb34797b5d213efbd25b307982126aa5b35b1b61ab1fa831e3bb38e9db15f71a48046bb9b7325aedd8386f40fb96ce73cb48727c3378bffe1baa3e17550607c9dbd654d4c743fb11a72438506b33a36d7ef9e21902d60182f9cf6213f0eedd13e0fbe961ef7192b5753b2b9378ed6456e49a979fdc911fee0a410bed8f9cf706af309e06c5e0c6f89a39f393929fbe8c1dc9dd34158f8c5435b73ec79c5ead6de05e93ef586ddcec15d04e34b6feaaac3a5787c418745111e54a1afaf8fb9ceaf7c00390edce1c180f63d346982d43be35e8b5be553c815368793409c2140cdcfb70cfa4f83b9a09e8cbd6c918c26c8d080f2041d75ae172138f0f43844b25e68f663e32bceecf856aed744c6406ffa31aa2753ce81e789c9ad020be672dee6fd6d45c791f494925d56db59b81d4a29cd0768758c36461a4e5eb8a129256d8c7a317e02c1dfb81fc69d5056834d3023f38bc29ce17fa1dd48e9f2c4b1cc669b58c24bc4dbf207bddb8254c604d0473969b5e7534dd4417ff262499e21a3842433e138d23ce05c8b611d0c1f2a6822d33dae9c1c524cd63f8c85403c07790b2fdb1a9cd56e2f3221d8365a256fed93c013d9271f3a1003127dad7750c3f6dd99ec96c09cc2d62f5068fda27ac203553cd340aa54c8b96c28c5a7e9404f243fb561d7e33c84de3db90a5257b6478247944f2daa2307c2ee218472dd4c6ff8d53cebab11ff603e540f9bfa4035e5642a32b7f4710e81cbc59d55d5d264bb5d80d386c63156c5763219d4c611eaf825184aaf66f3b90b2248c12b5b0414c6827da495fd30ff3c0985835a16ae6b6b47ee4ede9e887c1fef9384bbdea6bf332e1d86d30fcf11b5b7451dcb7e173c8dae5ddf10cc09e1f48aeb1382831e076e5b8af8e6b9d2bf11510f2448ee530880729c0cba84c50cc570464ab6aaae33970f8782a5fa1f818bd3d5dc78c25f703b598d812a4755c5754bd18bfa5bfcbc1b96bb76460e5838fafd2e25cef2d66feeea09e03b067c4a5725a7b1ac783ca4056e01ec9b16944ca5e5836c38fce2c54e288d3a6edce12633a9def40e337ecfa0cf8068f23018863102e6be6f1ca99458eef7e404a0e401cc38004aab5bcaa0c0aff2ce8dfcd0df581ceaf45cf46a40ffeeda03949c55615d3d9359a98a2318946fc2dc0635ce730f45ac59c489b30e14633e7d04563d0cfcb7e052127f1092f190f970d73c07a93c1e9bd636ee23db6e5f2ba1ea72259ce70644a7347c929c2f9e909d9ba42f44dddc6e1364e65d9e616b9a9bbb747f8d7afe78a38fe16ba4e00da2c864f502d3cbe771ac7097636d80c74a50a3c00258d1b11c4731889dca2ca743dbff417592ec87e6b36186e93b3f5eba869416c028200bae6b105bede4510cb0b2071a384828b977e3c9d7dd1da115b3c4fa0cb22f38867b1c450117dade4430fb943c183a7ff62875a12ac96a0275991fbb2a439e3a48e346e9443e27cc0f93eb39a72b00663ea54112b2b3c8ed789c48f4019bd8c9f3004d6923ceba877a50b9c0053e2ecf888ee596d763a2b7e0025081ad28ff0e206fdda15dcd1bf03f28b785d003e41f6fe09317c6359da3cf7e74e411a9fc90d6fb0daac30253213690efb2f0a2094011f353babba7d301b3a3dc1b5e50c70dd392be633c304e1b1a86fee71416cbcabd67a4266748f39e5f393280d4ced1113e912a829f7968a07d2c517ac00b04fb34590ea72383b358dc6c14d955dab9f4028815882b72d27c3d93cdfd7ebca598070ef9e4b7fb74dc37c5bc510d303cb97c0cd68ad4da9f81970ff5e8cb0a42aea0ac0024aab46b42112298bb307603686a7981a23afecd1aa1ca70dd2358f4f914e02ef79f77740f5e7d45af9162ae545eb153bc32c5d916d851393b7cd9f1e6e71fd347b2b72a5fcb60a3ea8927a72cdbe3fc29be63e23b6ab19e6800191682621ae3147b49500afb149760d54cd2c3cd95ee0e9c217c5c60cec89ef7adec5560b905badbe8cde57afd90cdb64ade3a65c06e589f4c7075c8f517cea4cb064758292286ef8bc506c658fe726688bc10f5979bd8b85534d4f281ff23e6bca75da2a86fd81a44b69e3fdef7c38e0c3908f57a8201e753ecd0b48ca740bd09e436b1607db1105dcfd376963bde52e1598c355f0eb493d9e88aa7a406c087d361b6c873d62a865b72a193312e1608e65e323be31c46fd61253ef5f40f4c8a09c49f17067efd391daffb97cbcf57b904bee5534eb6a819d0693099b30dd05e17788354f2a39b51c0b03159155b8c3334579ad5f649c02dfb760d79ef72c4e83d7863cb430da1ba8635226d65a44cdd68aacdc1745d61ec777532e07f77b0231496665f6dcc2011191f8693cac041eb24f1931cb062ba143435c72bde41f0d158d978496f16c270a610888bfae979d4decae02881df2e470258c6f2001fb5cbf6ab85f396a74f88961e37d4c9442f7fe1b077abc89aea90d26a27ba1cf2e7d587f25c38b2b390de15e673bebc74a91eb5ba8af6632e2ba9b2f3d5380a773cf755fa3ad5105c252c2c9de4e531f940a5665b27e8b3538c2900af830abceeb3d66b0b8cd92ae8c04e1173b9dd2039b9530f4e00234327bc5186098928f28eddad56e6d68df81973765408ea704f144f50c2b73a1438cba59a691dbe5c1286a98ce949e452f821f4361723c8cae7cfede86e7985b76658eee9b289194c421782554afaf9]]></content>
      <categories>
        <category>有感</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prettier 相关]]></title>
    <url>%2F2019%2F11%2F06%2Fprettier%2F</url>
    <content type="text"><![CDATA[Prettier 介绍Prettier 配置Prettier NPM 包yarn prettier:check; Prettier 插件]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Prettier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的Refs]]></title>
    <url>%2F2019%2F10%2F26%2FreactRefs%2F</url>
    <content type="text"><![CDATA[Refs官方说明： Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。 在React开发中、想要操作元素的状态一般是修改State、或者是修改传入的props。但是有时候一些效果不能通过如此操作实现，例如开发中常常碰到的： 输入框的焦点获取、比如打开登录界面登录框自动获取焦点 动态的根据一个元素的大小/距离 计算另外一个元素的大小 使用 Ref目前的React版本（16.11.0）中 Refs 的用法如下： 12345678910111213import React form 'react';class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); // 创建 this.myRef = React.createRef(); &#125; render() &#123; // 传入 return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; 对于节点的访问:1const node = this.myRef.current; 说明： 1.通过调用 React.createRef 创建了一个 React ref 并将其赋值给 this.myRef 变量。 指定 ref 为 JSX 属性，将this.myRef 传入; ref 和 key 一样不属于 props属性，二者都会被 React 特殊处理和维护。 ref 挂载以后，ref.current 指向 ref 所在节点 如果之前用过 React，你可能了解之前的 ref 可以通过 this.refs.inputRef 来访问 DOM 节点、如下所示，这个 ref 是字符串类型的，在使用上来说似乎更加方便。现在官方版本不建议再使用它，因为 string 类型的 refs 存在问题。它属于过时 API 并可能会在未来的版本被移除。 12345678910import React form 'react';class MyInput extends React.Component &#123; componentDidMount() &#123; this.refs.inputRef.focus(); &#125; render() &#123; // 还能用 但不建议 return &lt;input ref="inputRef" /&gt;; &#125;&#125; Ref的值官方文档中有说明，ref 的值根据节点的类型不同而有所不同： 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。可以访问元素的宽高等属性、input框还可以调用focus方法实现自动聚焦 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。即可以通过 current 调用组件中的方法 不能在函数组件上使用 ref 属性，因为他们没有实例。 回调 Refs更加精细的控制 refs 的传递, 可以达到类似 props 的传递效果，在需要的地方传入inputRef 123456789101112131415161718// 官方 Demofunction CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 官方说明： 如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 Refs 转发ref HookuseRef() 是 React 提供的在 Hooks 中获取 DOM 元素的方法。使用方法如下：12345678910111213141516import React, &#123; useRef&#125; from 'react';function RefDemo()&#123; const inputEl = useRef(null); const onButtonClick=()=&gt;&#123; inputEl.current.value="Hello, Ref"; console.log(inputEl); //输出获取到的DOM节点 &#125;; return ( &lt;&gt; &#123;/*保存input的ref到inputEl */&#125; &lt;input ref=&#123;inputEl&#125; type="text"/&gt; &lt;button onClick = &#123;onButtonClick&#125;&gt;展示&lt;/button&gt; &lt;/&gt; );&#125;export default RefDemo; 官方文档]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一个伪元素的骚操作]]></title>
    <url>%2F2019%2F10%2F25%2FbeforeAfter%2F</url>
    <content type="text"><![CDATA[用伪元素实现气泡框介绍 &nbsp;&nbsp;&nbsp;&nbsp;在项目开发中本来自己负责的基础组件库里面的 Tooltip 组件没有达到预期的效果(有八阿哥)… &nbsp;&nbsp;&nbsp;&nbsp;后来想到其实可以用伪元素实现一个类似的气泡弹窗，但是又想到一个问题：我每个元素的气泡内容不一样这尼玛怎么填进去呢？ &nbsp;&nbsp;&nbsp;&nbsp;于是乎，查文档、还真在文档里让我发现了一点有用的东西，通过 attr() CSS表达式和一个自定义数据属性 data-descr 创建一个纯CSS, 内容提示气泡如下： https://codesandbox.io/s/crazy-chatterjee-9h066?fontsize=14 相关属性： 自定义属性 data-desrc 表达式 attr() 兼容性： 还不错哦！！ 各种链接如下： data-descr_Demo链接 attr() 具体文档 canIUse) Demo地址 相关代码123456&lt;h1&gt;伪元素实现气泡提示&lt;/h1&gt;&lt;p&gt; &lt;span class="tooltip" data-descr="伪元素"&gt;伪元素&lt;/span&gt; &lt;span class="tooltip" data-descr="实现"&gt;实现&lt;/span&gt; &lt;span class="tooltip" data-descr="气泡提示"&gt;气泡提示&lt;/span&gt;&lt;/p&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546body &#123; font-family: sans-serif;&#125;.tooltip &#123; position: relative; display: inline-block; cursor: pointer;&#125;.tooltip[data-descr]:hover::after &#123; content: attr(data-descr); position: absolute; top: -24px; left: 0; min-width: 60px; max-width: 100%; height: 24px; padding: 0 8px; box-sizing: border-box; line-height: 24px; font-size: 10px; text-align: left; color: #fff; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; border-radius: 4px; background: #202020;&#125;.tooltip[data-descr]:hover::before &#123; content: ""; position: absolute; top: 0px; left: 15px; padding: 1px; box-sizing: border-box; border: 5px solid #202020; width: 0; height: 0; border-left-color: transparent; border-right-color: transparent; border-bottom-color: transparent; z-index: 99;&#125;]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单行文本换行与多行文本换行]]></title>
    <url>%2F2019%2F10%2F23%2Ftext-overflow%2F</url>
    <content type="text"><![CDATA[参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[React Poratls --传送门]]></title>
    <url>%2F2019%2F10%2F22%2Freact_Portal%2F</url>
    <content type="text"><![CDATA[在项目中常常会需要对话框、下拉列表、悬浮窗等交互的组件，当在父组件中使用一个下拉列表的时候，父组件的大小是固定的、同时还有一些overflow: hidden;子组件想要完全展示就变得比较困难，或者不能完全展示、或者阴影被父组件overflow给hidden掉了，同时在用overflow去清除浮动的影响的时候也要考虑到副作用，当元素比较多或者内容比较大的时候会不会被截断的问题。这个当想让子元素的层级最高而且不用被父元素给截断的时候就需要一个容器或者元素能够脱离父组件，至少从视觉上就得脱离父组件的影响。 Portals 是 react 16 官方提供的解决方案， 使得组件可以脱离父组件从而挂载在页面的任何地方。 在做组件层级的时候 应用的skill文档]]></content>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 React 中使用 mobx 进行状态管理]]></title>
    <url>%2F2019%2F10%2F14%2Fmobx-react%2F</url>
    <content type="text"><![CDATA[observableinjectcomputedaction autorunRunInActionReaction 尽量使用箭头函数 调试 toJS 需要引入 =&gt; 不如直接 JSON.stringify()方便 不用使用数组索引或者任何将来可能会改变的值作为 key 。如果需要的话为你的对象生成 ids。 参考技巧 1234567var array = [&#123;name:'武汉'&#125;, &#123;name: '北京'&#125;, &#123;name:'上海'&#125;, &#123;name:'天津'&#125;];var resultArray = array.sort( function compareFunction(param1, param2) &#123; return param1.name.localeCompare(param2.name,"zh"); &#125;);console.log(resultArray); 根据现有的状态或其它计算值衍生出的值，响应式的产生一个可以被其它 observer 使用的值1234567891011121314import &#123;observable, computed&#125; from "mobx";class OrderLine &#123; @observable price = 0; @observable amount = 1; constructor(price) &#123; this.price = price; &#125; // computed 不支持箭头函数的写法 @computed get total() &#123; return this.price * this.amount; &#125;&#125; 想不产生一个新值，而达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用。 autorun 中的值必须要手动清理才行 1234567891011121314151617181920212223242526272829303132// 请求底部的 table Plan 绑定数据@action fetchShopPlanList = (): ActionResponse =&gt; &#123; const [begin, end] = this.dateRange; return http .post(ApiBaseinfo_Admin_Restaurant_restaurantID_menuCalendarByDateRange, &#123; ':restaurantID': globalStore.currentShopID, begin, end, &#125;) .then((&#123; error, data &#125;) =&gt; &#123; if (error) &#123; return &#123; error &#125;; &#125; runInAction(() =&gt; &#123; const &#123; menuCalendarList &#125; = data; // 遍历筛选绑定菜单项 this.boundObj = menuCalendarList.reduce((preObj, mealPlan) =&gt; &#123; const &#123; color, name, date &#125; = mealPlan; if (color) &#123; preObj[`$&#123;date&#125;_$&#123;name&#125;`] = color; &#125; return preObj; &#125;, &#123;&#125;); // 在一个请求的 action中直接去修改 state,可能会存在mobx 检测不到的情况，需要包裹 runInAction this.shopCalendarList = data.menuCalendarList; &#125;); return &#123; data &#125;; &#125;);&#125;;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F13%2FReactComponent%2F</url>
    <content type="text"><![CDATA[title: react中的组件: Component、PureComponent、functionComponentReact 哲学组合优于继承 class Componentfunction ComponentPureComponent组件库中组件的设计stateLess常用样式尽量少]]></content>
  </entry>
  <entry>
    <title><![CDATA[classnames 的用法总结]]></title>
    <url>%2F2019%2F10%2F13%2Fclassnames%2F</url>
    <content type="text"><![CDATA[React 和 Vue class对比在React项目开发中，类名的管理不像 Vue 那么方便; 如何为组件添加 CSS 的 class？传递一个字符串作为 className 属性： render() { return Menu}CSS 的 class 依赖组件的 props 或 state 的情况很常见： render() { let className = ‘menu’; if (this.props.isActive) { className += ‘ menu-active’; } return Menu} 在官方的提示下推荐开发者使用 classnames npm 包来管理自己的类名会方便很多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function () &#123; 'use strict'; // =&gt; Object.hasOwnProperty 用于判断某个成员是否在对象内 var hasOwn = &#123;&#125;.hasOwnProperty; function classNames () &#123; // 存储 className 值 var classes = []; // 循环实参， arguments就是实际调用函数传入的参数，类似数组 for (var i = 0; i &lt; arguments.length; i++) &#123; // 获取实参value var arg = arguments[i]; // 跳过false条件 =&gt; false, null, undefined, NaN, 空, ... if (!arg) continue; // 判断传入参数的类型 var argType = typeof arg; // 如果参数的类型是 string 或者 number if (argType === 'string' || argType === 'number') &#123; // 直接追加到classes数组后面 classes.push(arg); // 如果参数是数组并且长度大于0 &#125; else if (Array.isArray(arg) &amp;&amp; arg.length) &#123; // 调用自身函数，利用apply可以将数组转成字符串 var inner = classNames.apply(null, arg); // 现在是一个字符串，隐士判断布尔值 if (inner) &#123; // 追加到数组后面 classes.push(inner); &#125; // 如果传入的参数是对象 &#125; else if (argType === 'object') &#123; // 对object进行遍历 for (var key in arg) &#123; // 判断key是否存在arg对象内并且key的值隐士转换为true if (hasOwn.call(arg, key) &amp;&amp; arg[key]) &#123; // 将值追加到classes数组后面 classes.push(key); &#125; &#125; &#125; &#125; // 将数组连接成字符串以空格拼接 =&gt; a b c return classes.join(' '); &#125; // 如果是node.js环境运行 if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; classNames.default = classNames; module.exports = classNames; // 如果用的requirejs模块管理 AMD &#125; else if (typeof define === 'function' &amp;&amp; typeof define.amd === 'object' &amp;&amp; define.amd) &#123; define('classnames', [], function () &#123; return classNames; &#125;); // 否则运行于浏览器环境 &#125; else &#123; window.classNames = classNames; &#125;&#125;()); classnames github库]]></content>
      <categories>
        <category>NPM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VSCode 快捷键(持续更新)]]></title>
    <url>%2F2019%2F10%2F13%2FVsCodeShortCuts%2F</url>
    <content type="text"><![CDATA[文档编辑中键盘快捷方式光标移动 快速移动光标（按单词跳: option 行首行尾移动光标 : command 移动到文件头尾: commad 上下方向键 选中 选中操作: shift 方向键操作选中方向 选中光标所在单词: command D 其它 搜索时切换搜索结果: shift Enter 文件相对路径: shift command H 原shortCut =&gt; 自定义 command H 新建未命名文件: command N 搜索光标所在单词: command E 选中所在的代码块(select Bracket)，对花括号的代码块较友好: option command B 切换tab: option commmad 删除整个单词: option backspace 向上下复制整行: option shift 上下方向键 找到当前文件所有与选中相同的文档 达到批量修改的目的(change all ocurrences): shift command I]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F29%2FNginxGetStart%2F</url>
    <content type="text"><![CDATA[参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[React-router V4]]></title>
    <url>%2F2019%2F08%2F21%2FreactRouter%2F</url>
    <content type="text"><![CDATA[React 创建的单页应用中、通过路由来控制页面间的跳转，常用的就是 react-router、react-router-dom React Router中有三类组件 路由组件 BrowserRouter, HashRouter 路由匹配组件 Route, Switch 导航、链接组件 Link 基于 React Router 的 web 应用，根组件应该是一个 router 组件（BrowserRouter，HashRouter ）。 项目中，react-router-dom 提供了和两种路由。两种路由都会创建一个 history 对象。如果我们的应用有服务器响应 web 的请求，我们通常使用组件; 如果使用静态文件服务器，则我们应该使用组件 通常都是使用 DemoLink 组件最终会渲染为 HTML 标签 ，它的 to、query、hash 属性会被组合在一起并渲染为 href 属性。虽然 Link 被渲染为超链接，但在内部实现上使用脚本拦截了浏览器的默认行为，然后调用了history.pushState 方法]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 相关]]></title>
    <url>%2F2019%2F08%2F15%2Fwebpack%2F</url>
    <content type="text"><![CDATA[及时补一篇篇都是欠下的债 参考链接官方文档传送门]]></content>
      <categories>
        <category>前端</category>
        <category>webPack</category>
      </categories>
      <tags>
        <tag>WebPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式学习与整理]]></title>
    <url>%2F2019%2F08%2F15%2FDesignPatterns%2F</url>
    <content type="text"><![CDATA[设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>设计模式</tag>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios]]></title>
    <url>%2F2019%2F08%2F15%2FAxios%2F</url>
    <content type="text"><![CDATA[先从fetch讲起一个简单的fetch例子如下： 123456789101112131415161718192021fetch('./api/person.json') .then( function(response) &#123; if (response.status !== 200) &#123; console.log('Looks like there was a problem. Status Code: ' + response.status); return; &#125; // Examine the text in the response // 将返回数据 Json 化 response.json().then(function(data) &#123; console.log(data); &#125;); &#125; ) .catch(function(err) &#123; console.log('Fetch Error :-S', err); &#125;); 1. .json()返回一个被解析为JSON格式的`promise`对象，当获取成功时，我们使用 json() 读取并解析数据 使用async/await简化由于Fetch底层是用Promise实现，我们可以直接用async来优化上面的代码，减少回调，使其更加语义化、容易理解， 代码如下： 12345678910async function geturl()&#123; try&#123; let res = await fetch('./api/some.json') if(res.status == 200)&#123; console.log(await res.text()) &#125; &#125; catch(err)&#123; console.log(err) &#125;&#125; 12345678910// response 其他返回数据fetch('users.json').then(function(response) &#123; console.log(response.headers.get('Content-Type')); console.log(response.headers.get('Date')); console.log(response.status); console.log(response.statusText); console.log(response.type); console.log(response.url);&#125;); Response 类型当我们发起一个Fetch请求时，返回的response响应会自带一个response.type属性（basic、cors、opaque）。response.type属性说明了异步资源的来源，同时还有相应的处理方式。当我们发起一个同源请求时，response.type为basic，而且你可以从response读取全部信息。如果我们访问一个非同源域名，并且有返回相应的CORs响应头时，那么该请求类型是cors。 cors和basic很相似，就除了cors响应里你无法访问Cache-Control，Content-Language，Content-Type，Expires，Last-Modified和Pragma当我们对一个不同源的域名发起请求时，如果返回的响应头部没有CORS信息，那么这个response对应的类型就是opaque类型。一个opaque响应是无法读取返回的数据、状态，甚至无法确定这个请求是否成功。我们可以自定义Fetch请求的模式，要求返回对应类型的响应，有以下几种响应： 1.same-origin 只返回同源请求，其他类型会被reject 2.cors 接收同源、非同源请求，返回有CORs头部的响应 3.cors-with-forced-preflight 在发出请求前会先做一次安全性检查 4.no-cors 用来发起没有CORS头部并且非同源请求，并且会返回opaque响应。但是目前这种类型只能在Service Worker里使用，在window.fetch里不能用 POST请求类型使用Fetch发起Post请求时，需要手动设置method参数和body参数，如下：1234567891011121314fetch(url, &#123; method: 'post', headers: &#123; "Content-type": "application/x-www-form-urlencoded; charset=UTF-8" &#125;, body: 'foo=bar&amp;lorem=ipsum' &#125;) .then(json) .then(function (data) &#123; console.log('Request succeeded with JSON response', data); &#125;) .catch(function (error) &#123; console.log('Request failed', error); &#125;); 带 COOKIE 发送请求在异步请求中带上cookie参数，那么需要显式指定credentials参数： 123fetch(url, &#123; credentials: 'include'&#125;) AxiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装npm 安装：1$ npm install axios 使用cdn:1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; GET 请求POST 请求响应结构响应返回包含信息：12345678910111213141516&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;&#125; 文档传送门]]></content>
      <categories>
        <category>Skill</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E2E 测试]]></title>
    <url>%2F2019%2F08%2F14%2FE2ETest%2F</url>
    <content type="text"><![CDATA[测试参考链接 小程序自动化小程序自动化SDK为开发者提供了一套通过外部脚本操控小程序的方案，从而实现小程序自动化测试的目的。 通过该 SDK，你可以做到以下事情： 控制小程序跳转到指定页面 获取小程序页面数据 获取小程序页面元素状态 触发小程序元素绑定事件 往 AppService 注入代码片段 调用 wx 对象上任意接口 安装小程序自动化SDK：1npm install miniprogram-automator --save-dev]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除 inline 元素之间的间距]]></title>
    <url>%2F2019%2F08%2F13%2FspaceBetweenInlineBlock%2F</url>
    <content type="text"><![CDATA[这个问题曾经在哪一次的面试中被问到过，当时只知道是空白的文本节点在作祟，但是问到解决的方法，却没有答上来，今天在项目里碰到了详细了解了一下，记录一下。 详情参考]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F12%2FsetPerformance%2F</url>
    <content type="text"><![CDATA[title: 利用set提高性能tags: JavaScriptcategories: 前端 JavaScript 经过实际比较来说，如何减少重绘和回流比选择数组还是Set来操作数据对于前端性能而言更为重要 详情]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F08%2F05%2FArray%2F</url>
    <content type="text"><![CDATA[数组定义： 一个存储元素的线性集合， 元素可以通过索引（通常为数字）来任意存取。 数字索引在内部被转换为字符串类型、这是因为在javaScript中对象的属性名必须是字符串。而数组只是一种特殊的对象 创建数组 通过构造函数 123456&lt;!-- 传入一组元素进行数组初始化 --&gt;var arr = New Array(1, 2, 3, 4, 5);print(arr.length); // 5&lt;!-- 只传一个元素，声明数组的初始化长度, 其中每个元素初始化为 undefined --&gt;var arr1 = new Array(10);print(arr1.length); // 10 通过字面量 [] 创建 123var arr1 = [];var arr2 = [1, 2, 3, 4];print(arr2.length); // 4 区别虽然两种创建数组的方法产生的效果一样，但是还是存在一些细微的差别。而且你会发现，在JS开源库中，通过第一种方法来创建数组基本上看不到。 1234567console.time('using[]')for(var i=0; i&lt;2000000; i++)&#123;var arr = []&#125;;console.timeEnd('using[]') // using[]: 29.630859375msconsole.time('using new')for(var i=0; i&lt;2000000; i++)&#123;var arr = new Array&#125;;console.timeEnd('using new') // using new: 39.93798828125ms 通过对比会发现使用new关键字来创建数组花费的时间更长，实际上使用new来创建会多一个实例化的过程，在Javascript里分配大量的new变量地址是一项很慢的操作，为了效率起见，你应该始终使用对象符号。虽然只有在大批量数据的情况下才会有影响. 创建一个字符串的方式有：‘字符串’或者是new String(‘字符串’)，一种是直接创建了一个字符串，一个是调用字符串的构造函数创建字符串对象然后再创建这个字符串，中间多了一个创建对象的过程，也许这在一般情况下是看不出什么区别的，但是像上述例子中，当数据足够大的时候，就会发现了问题所在。因此，如果可以通过[]创建一个纯净的数组，就不需要通过new Array()来创建数组。 数组方法isArray 存取函数 用来访问数组元素的函数，返回目标数组的某种变体 indexOf() 返回第一个与参数相同的元素的索引, 不存在返回 -1 lastIndexOf 返回相同元素中最后一个元素的索引,不存在返回 -1 数组的字符串表示 join() toString() 12345var names = ["David","Cynthia","Raymond","Clayton","Mike","Jennifer"];var namestr = names.join();print(namestr); // David,Cynthia,Raymond,Clayton,Mike,Jennifernamestr = names.toString();print(namestr); // David,Cynthia,Raymond,Clayton,Mike,Jennifer 由已有数组创建新的数组 concat() 合并多个数组创建一个新数组splice() 截取一个数组的子集创建一个新数组slice() 使用 splice() 方法为数组添加元素，需提供如下参数：• 起始索引（也就是你希望开始添加元素的地方）；• 需要删除的元素个数（添加元素时该参数设为 0）；• 想要添加进数组的元素。1234var nums = [1,2,3,7,8,9];var newElements = [4,5,6];nums.splice(3,0,newElements);print(nums); // 1,2,3,4,5,6,7,8,9 可变函数 能够改变数组的内容的函数 push() 在末尾添加元素pop() 删除末尾的元素 shift()unshift() 添加元素到数组的开头 reverse() 翻转数组sort()对数组进行排序是经常会遇到的需求，如果元素是字符串类型，那么sort() 就非常好使：123var names = ["David","Mike","Cynthia","Clayton","Bryan","Raymond"];names.sort();print(names); // Bryan,Clayton,Cynthia,David,Mike,Raymond 但是如果数组元素是数字类型，sort() 方法的排序结果就不能让人满意了：1var nums = [3,1,2,100,4,200];nums.sort();print(nums); // 1,100,2,200,3,4sort() 方法是按照字典顺序对元素进行排序的，因此它 假定元素都是字符串类型，在上一个例子中，即使元素是数字类型，也被认为是字符串类型。为了让 sort() 方法也能排序数字类型的元素，可以在调用方法时传入一个大小比较函数，排序时，sort() 方法将会根据该函数比较数组中两个元素的大小，从而决定整个数组的顺序。对于数字类型，该函数可以是一个简单的相减操作，从一个数字中减去另外一个数字。如果结果为负，那么被减数小于减数；如果结果为 0，那么被减数与减数相等；如果结果为正，那么被减数大于减数。12345function compare(num1, num2) &#123; return num1 - num2;&#125;var nums = [3,1,2,100,4,200];nums.sort(compare);print(nums); // 1,2,3,4,100,200 sort() 函数使用了 compare() 函数对数组按照数字大小进行排序，而不是按照字典顺序。 迭代器方法 其实可以多展开来讲的 map foreach filter reduce 的区别 forEach() every() some() map() filter()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一台电脑配置多个SSH]]></title>
    <url>%2F2019%2F07%2F31%2FmultiSSH%2F</url>
    <content type="text"><![CDATA[配置多个SSH在工作中多访问公司的gitlab仓库，而在生活中又有自己的github仓库记录一下方便日后查找 一般电脑中的SSH key 存放在 ～/.ssh目录中 如果有配置过的话存在 id_rsa \ id_rsa.pub 私钥和公钥, 将公钥配置到需要的代码平台 生成SSH key 本地配置多个ssh key 1、为公司生成一对秘钥ssh key 1ssh-keygen -t rsa -C 'yourEmail@xx.com' -f ~/.ssh/gitlab_id_rsa 2、为github生成一对秘钥ssh key 1ssh-keygen -t rsa -C 'yourEmail2@xx.com' -f ~/.ssh/github_id_rsa 3、在~/.ssh目录下新建名称为config的文件（无后缀名）。 用于配置多个不同的host使用不同的ssh key，常用内容如下： 123456789101112# gitlabHost gitlab.planetmeican.com HostName gitlab.planetmeican.com Port 2345 User git PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 配置文件参数123456# Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件# port: 端口号，一般不需要配置# HostName : 要登录主机的主机名#PreferredAuthentications: 授权验证方式# User : 登录名# IdentityFile : 指明上面User对应的identityFile路径 4、分别往gitlab和github上添加生成的公钥]]></content>
      <categories>
        <category>倒腾</category>
        <category>Note</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux中Provider、connect]]></title>
    <url>%2F2019%2F07%2F29%2Fprovider%26%26connect%2F</url>
    <content type="text"><![CDATA[react-redux中Provider详情]]></content>
      <categories>
        <category>React</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[serverless了解]]></title>
    <url>%2F2019%2F07%2F29%2Fserverless%2F</url>
    <content type="text"><![CDATA[serverless 根据 CNCF 的定义，Serverless 是指构建和运行不需要服务器管理的应用程序的概念。]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>Skill</tag>
        <tag>倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 参数]]></title>
    <url>%2F2019%2F07%2F29%2FnpmParams%2F</url>
    <content type="text"><![CDATA[npm 参数npm install -g webpacknpm install prop-types –save-dev]]></content>
      <categories>
        <category>Skill</category>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 笔记]]></title>
    <url>%2F2019%2F07%2F28%2FgitNote%2F</url>
    <content type="text"><![CDATA[Git 常用的命令笔记Commitizen是一个撰写合格 Commit message 的工具。 本地分支重命名git branch -m old new 链接远程仓库123git remote add origin 仓库地址仓库地址：https://git.coding.net/xxxxxxxxxxxxx/my-project.git git push -u orgin master 删除远程仓库1git remote remove origin 修改远程仓库（源地址）1git remote set-url origin [] 如下： 1234567891011Project mctDev/cafeteria-supplier-desktop was moved to another locationThe project is now located under cafereria-fe / cafeteria-supplier-desktopTo update the remote url in your local repository run (for ssh):git remote set-url origin git@gitlab.planetmeican.com:cafereria-fe/cafeteria-supplier-desktop.gitor for http(s):git remote set-url origin https://gitlab.planetmeican.com/cafereria-fe/cafeteria-supplier-desktop.git 原理解析 git remote set-url –add origin 就是往当前git项目的config文件里增加一行记录 config文件打开方式有两种： 使用命令git config -e 在当前git项目的根目录下，文件位于 .git/config (.git目录为隐藏文件) 你每执行一次git remote set-url –add origin 就会增加一行，如下图： git remote -v:显示当前所有远程库的详细信息，显示格式为 远程库名字 url连接(类型) 参考链接 git checkout的用法12345git checkout // 不跟参数，则对工作区进行检查 可以返回工作区文件的状态git checkout -b 分支名 // 切换到对应分支 如果没有则新建一条分支git checkout -B 分支名 // 强制切换分支 如果存在同名分支会发生覆盖git checkout commit_id(hash) // 切换到对应的commit版本 （分离头指针） //此时的HEAD不指向分支，指向对应的commit_id 通过 git checkout master 切回分支 checkout命令详解参考 撤销本地修改的文件12git checkout [filename] // 撤销某个文件的修改git checkout . // 撤销所有修改的文件 撤回 add/commit将add到暂存区后的提交撤回 git reset head 文件名 修改commit标注12commit -m &quot;aaaa&quot; // 提交一个commitgit commit --amend =&gt; 开启vim编辑器 编辑后保存退出 撤回commit 12git reset --soft commit_id // 撤回commit 到commit_id soft 只是撤回commit 本地文件不会修改git reset --hard commit_id // 撤回commit 到commit_id hard 只是撤回commit 本地文件回退 拉取远程分支1git pull origin [分支名] 添加/删除远程分支 将本地分支推送到远程分支上，如果远程分支不存在，则创建此远程分支 12345git push origin 本地分支名:远程分支名$ git push origin test:master // 提交本地test分支作为远程的master分支 $ git push origin test:test // 提交本地test分支作为远程的test分支//好像只写这一句，远程的github就会自动创建一个test分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 1git push origin :远程分支名(你要删除的远程分支名) git reflog 可以显示已删除的操作]]></content>
      <categories>
        <category>Skill</category>
        <category>Note</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工具整理]]></title>
    <url>%2F2019%2F07%2F22%2F0722%2F</url>
    <content type="text"><![CDATA[开发工具:1.代码编辑器 visual studio Code 插件 12345678910111213141516- Chinese 中文插件- language-Stylus - LeetCode- Vetur- Prettier- React/Redux/react-router Snippets react便捷输入- Prettier- GitLens- Markdown All in One- npm Intellisense- Quokka.js- Relative Path- JavaScript code snippets- CSS Peek- Bracket Pair Colorizer- Better Comments 主题 1one dark pro 2.浏览器及插件 Chrome 浏览器 12345678910111213Ghelper 翻墙插件 可在GitHub上获取ADBlockmarinara（番茄工作法助理）FireShot扩展管理器WEB前端助手划词翻译ImagusOctotreeReact/Vue develop ToolChrono掘金插件Json-handle 3.其他工具 命令行开发工具： iterm2 homebrew oh-my-zsh Git/gitLab &amp;&amp; 配置SSH node &amp;&amp; NVM 123nvm install 8.9.0 // 安装需要的node版本nvm use 8.9.0 // 切换使用相对应的node版本]]></content>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二零一九年下半年大概规划]]></title>
    <url>%2F2019%2F07%2F15%2F2019Plan%2F</url>
    <content type="text"><![CDATA[加密文章，可能是个人情感宣泄或者生活记录。 bdb49a22e85b81ca66c5f2308ef0a8569ec6562a7ed4db8e9c09f2138c76faf2733805df88b8b8cb5b45885973d59a2a8fe1141139a961fd5e70939c9a5b264218e53cfb8c62b46acad9e1896c8756d35d1c8842453f477a481f84056db7e869d1b2b3ed448892fb8f862c4de7f3972f215f223e029c23174739368acad532b631d6ae18b1a3fd399a69638a27c80435b5a9a55def547476b29ecbca359ffcc9727b7dfa9dc6a914fb3def4b3966e43d369506c162f9ee0d3902cf1871a8787d8eadcec7627f3f1ee7e5b0f7a87e07cc9c6f323fb2207dd0f1d3cc4db08d020821a4228cd85c8c9ee5a8c9e47417930fa16860ef457de3e12726936eb3a910111fa0df36c8c99af287861f068da4554fa4965d1fb533a2ed7ee4e9bdbb4b525435e12a99edeb6dc63d9a1fc6f41c2a146b91162debf199ef31ac8be828b63423d0ce211148f3091625f5f537423369b1c75ac7017ba8db64a89cf13df7d730f7cfe1a706332ccf3f9dd0206c43c54e05b555c82556c84ffbe95920a65e5a1a9f9a985ef7149368701c4d89d44da29694ca6aca855a9d48cb45ab921c2d4bb508117300c3cf5edb3e62eb12a8713ca0b2c734deb7ee2fb52efe891557691467edba3e16c6f33f0568d5f6bb7aa8e20e43501770b52a700824dc4087a300fbb033bfc579593911f1c73ed6453daf762c68d7d4b8deb2d172f3db2ddee6139d6f1ee67f4dede27475ed22dafc57b1f23399a97ff33584f567a8e5f1366ecad8a6043518d949c8ac798a926959032915f9b55fc289eaa1fee452e72252952c26b4c2d2ee941e3664215d46f557187bdc01d46dec9ee0f6b172a073c15dc6bf70fff5dae8847d4a0fbbab94bf684d3cdc33bde3121e48116c2550765abab27e1575be602719211f36618c14d1be5c7c41f3acaecc2392e970dd19af19be6f2634c8eb0eec0cc0ef6003bca72e5cbfc2100a5bca385122666f71facebb97e9e17240abd75b987746860c97e018a69277e9c6ed63c3bd519dfeb16bcbdfc1ec5ac0fb03afc99a527e2f6883c9f55df5aa8360f8a5c6d6f0c9aca6472efdae89b64c3befc3e831384729ce1cb912d9186ff8c812]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESLint]]></title>
    <url>%2F2019%2F07%2F07%2FESLint%2F</url>
    <content type="text"><![CDATA[代码规范的意义ESLint]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如约而至]]></title>
    <url>%2F2018%2F09%2F05%2Fappoint%2F</url>
    <content type="text"><![CDATA[专辑： 寻宝游戏歌手：许嵩作曲 : 许嵩作词 : 许嵩如果早知道那天是我们最后一面我绝不会和你谈论琐事浪费时间人生里看似偶然却又必经的告别无约而至 无人可免有一回置身某个似曾相识的场景那一刻我忽然感应你就在我身边过去、当下、未来未必确有其界限或许爱能穿越时间 抵达永远等到秋叶终于金黄等到华发悄然苍苍我们相约老地方等到人已不再奔忙等到心也不再轻狂我们相约老地方等到记忆只剩精华等到笑容不掺伪装我们相约老地方等到释怀所有悲伤等到体谅世事无常我们相约老地方 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"appoint.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>😊</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基本数据类型和引用类型的区别]]></title>
    <url>%2F2018%2F07%2F30%2Ftype%2F</url>
    <content type="text"><![CDATA[Js 基本数据类型js基本数据类型包括：undefined,null,number,boolean,string.基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值 1.基本数据类型的值是不可改变的 任何方法都无法改变一个基本类型的值是不可改变的，比如一个字符串： 1234567var name = "change";name.substr();//hangconsole.log(name);//changevar s = "hello";s.toUpperCase()//HELLO;console.log(s)//hello 通过这两个例子， 我们原来发现定义的变量name 的值始终没有发生改变，而调用substr() 和 toUpperCase() 方法后返回的是一个新的字符串，跟原先定义的变量name 并没有关系 或许有人会有一下的疑问， 看代码：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化之浏览器篇]]></title>
    <url>%2F2018%2F07%2F20%2FBetter%2F</url>
    <content type="text"><![CDATA[把 Css 放在head 中加载 在浏览器解析完head 部分后、让浏览器知道需要引入哪些css文件，开始并行的去下载css资源，一边下载Css文件一边解析Html, 能够使页面更早的开始渲染 让页面更早的开始渲染、避免闪屏 （DOM 结构先加载出来，css慢了一拍 页面重新渲染） 最好能包含关键渲染路径的样式、首页的样式应该尽快的完成加载、提高用户体验 JS放在 body 标签结束前加载 js 资源的加载会阻塞 HTML 的解析 和 Css的渲染 不使用CSS 表达式 看似强大， 实际性能开销很大，可能导致页面卡顿 用外链的方式引入css 和 js 通过使用外链可以减少html 文件的体积 作为外链文件、Css/Js 可以作为静态资源、通过合理的利用浏览器的缓存对需要的文件进行缓存； 在第二次访问时可以加快页面的加载速度 不要重复加载JS 在IE中，例如在加载一个jquery以后再加载一个jquery，仍然是算作两个不同的请求，不能发挥缓存的优势 重复加载js意味着更长的JS执行时间 用 Get 方式发起 Ajax 请求 Get 方式可以缓存 如果是获取信息 Get 更加语义化 如果是提交数据 使用Post 更加语义化 组件延迟加载 规划页面中引用的姿态资源加载顺序、优先级的能力 保障关键页面资源的优先加载: 浏览器的并发数限制 在同一个域名下面，一般现代浏览器的并发数为6 按需加载 Lazyload 典型： 电商网站 在图片比较多的电商网站中，lazyload 十分实用 data-src -&gt; src 避免在页面中使用iFrame 会阻塞父文档的 onload 事件 即使是空白iFrame 也比较耗时 减少COOKIE体积 COOKIE每次请求都会全都带上COOKIE了解更多 每次请求跟主文档相关的信息，所有的cookie都会带上 减少 JS 中的 DOM 访问 JS中对DOM 的访问是不可避免的, 但可以进行一下优化 对于查找到的元素， 先将其缓存在变量中 节点增加时合理利用 DocumentFragment 不要用JS 去频繁修改样式 使用常见的图片优化手段 相比代码， 图片的体积很大 不要在HTML中缩放图片在实际中使用什么尺寸的图片就提供多大尺寸的图片 徒增渲染开销， 提供适当尺寸即可 不要把图片的src置空 在主流浏览器中 IE、Chrome、FireFox 都会引发指向当前主文档的额外请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp 正则表达式]]></title>
    <url>%2F2018%2F07%2F18%2FregExp%2F</url>
    <content type="text"><![CDATA[RegRxp(正则表达式) 简化对字符串的操作 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等 什么是正则？规则、模式; 强大的字符串匹配的工具 风格 js风格: const reg = new RegExp(‘a’, i) perl风格: const reg = /a/i 转义字符 转义字符 说明 \d 数字 [0-9] \D 除了数字吃 [^0-9] \ 斜杆 \ \n 换行 \w 英文 数字 下划线 [a-z0-9_] \W 非英文 数字 下划线 [^a-z0-9_] \s 空格 \S 非空白字符 特殊字符(元字符) [] 方括号 123456// [abc] 表示a或者b或者c const re = /[abc]pc/g// 范围匹配[a-z] [0-9] [^a-z] // 匹配非英文部分 限定符(量词) 基本形式： {n}表示出现的次数 12// 8位电话号码 /[1-9]\d&#123;7&#125;/ // 以非零数字开头后面八位随意 表示出现次数范围： {n, m} 表示出现最少n次 最多m次 1/[1-9]\d&#123;4, 10&#125;/ // QQ 正则 不限次数：{n, } 表示最少n次， 最多不限 . 任意字符 *: =&gt; {0, } 任意次 +: 若干 =&gt; {1, } 最少一次 最多不限 ?: 最少零次 最多一次 =&gt; {0, 1} ^: 行首 $: 行尾 1(0\d&#123;2,3&#125;-)?[1-9]\d&#123;7&#125; // 固话区号 010-2473544 方法 search 返回匹配的位置 match 把所有匹配的东西都提取出来 replace 字符串替换,替换所有匹配的字符串，返回替换以后的字符串 test 检验字符串是否符合正则 返回Boolean 特性 只要字符串一部分符合要求就返回true 12345// 校验邮箱const email = '你好啊heiliu@Gmail.com'const re = /\w+@[a-z0-9]+\.[a-z]+/re.test(email) // 后半部分符合 返回 true const re1 = /^\w+@[a-z0-9]+\.[a-z]+$/ // 限制首尾 应用例子 查找字符串中的数字并返回 1234// 查找字符串中的数字 const str = '123ask32lks,alf21lksa12e45l3'const reg = /\d+/g // globalconsole.log(str.match(reg)) 敏感词过滤 1234// replace 的用例const reg = /匹配|出来/;const str = '把所有匹配的东西都提取出来 'console.log(str.replace(reg, '***')) // 把所有***的东西都提取***]]></content>
      <categories>
        <category>前端</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件通信]]></title>
    <url>%2F2018%2F07%2F15%2FVueComponentsConnect-md%2F</url>
    <content type="text"><![CDATA[组件 (Component) 是 Vue.js最强大的功能之一。组件可以扩展，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 通信类型父组件与子组件通信 父组件给子组件传递数据 props: 使用props，父组件可以使用props向子组件传递数据 1234567891011121314151617181920// 父组件 &lt;template&gt; &lt;child :msg="message"&gt;&lt;/child&gt;&lt;/template&gt; &lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child &#125;, data () &#123; return &#123; message: 'father message'; &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// 子组件 &lt;template&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; // props 另一种写法, 不声明类型与默认值 // props: ['msg'] props: &#123; msg: &#123; type: String, required: true &#125; &#125; &#125; &lt;/script&gt;``` - 子组件向父组件通信 &gt; 在Vue 中子组件一般不具有操作数据和处理事件的权利，所有的数据和事件的处理都要交给父组件进行操作 **方法一 :** 在子组件中通过$emit()将组件内部的时间传递给父组件的事件进行 ```js // 父组件&lt;template&gt;&lt;child @msgFunc="func"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default &#123;components: &#123; child&#125;,methods: &#123; func (msg) &#123; console.log(msg); &#125;&#125;&#125;&lt;/script&gt;// 子组件 &lt;template&gt;&lt;button @click="handleClick"&gt;点我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;props: &#123; msg: &#123; type: String, required: true &#125;&#125;,methods () &#123; handleClick () &#123; // 提交出去的处理方法的名称与父组件接收的需一致 this.$emit('msgFunc'); &#125;&#125;&#125;&lt;/script&gt; ``` **方法二:** 通过修改父组件传递的props来修改父组件数据 &gt; 这种方法只能在父组件传递一个引用变量时可以使用，字面变量无法达到相应效果。因为饮用变量最终无论是父组件中的数据还是子组件得到的props中的数据都是指向同一块内存地址，所以修改了子组件中props的数据即修改了父组件的数据。&gt; 但是并不推荐这么做，并不建议直接修改props的值，如果数据是用于显示修改的，在实际开发中我经常会将其放入data中，在需要回传给父组件的时候再用事件回传数据。这样做保持了组件独立以及解耦，不会因为使用同一份数据而导致数据流异常混乱，只通过特定的接口传递数据来达到修改数据的目的，而内部数据状态由专门的data负责管理 --- ## 兄弟组件进行通信 &gt; 刚开始学习使用Vue时, 在Vue项目中的两个兄弟组件之间如果要进行通信， 通常会通过一个父组件进行数据请求再给子组件传递数据。 - Vuex 是官方推荐的状态管理方案, 不过如果只是中小型项目，状态管理也没有很复杂的话，使用 Vuex 有种杀鸡用牛刀的感觉 - Vue 官方推荐使用一个 Vue 实例作为中央事件总线, 即 `EventBus` ,在需要使用的地方import该Bus &gt; EventBus 解决了兄弟组件之间的事件传递问题，它的本质是订阅发布者模式，同一个事件发布组件发布了，订阅组件就能获得事件的改变摆脱了兄弟组件之间传值需要父组件转达，Vue事件实例，作为中间者不在页面上显示且具有vue的API 如 emit on ```js // bus.js =&gt; new 一个 Vue 实例 import Vue from 'vue' export default new Vue() // clickComponent.vue 相当于发布者, 在需要的组件中订阅就能进行通信 &lt;template&gt; &lt;div&gt; &lt;a href="#"class="click" :data-index="index" @click.prevent="doClick($event)"&gt;点我&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Bus from '@/common/bus.js' export default &#123; props: &#123; index: Number &#125;, methods: &#123; doClick (event) &#123; // console.log(event.target.dataset.index) Bus.$emit('getTarget', event.target.dataset.index) // this.$emit('global: getTarget', event.target.dataset.index) &#125; &#125; &#125; &lt;/script&gt; // showComponents.vue 另一个兄弟组件 进行订阅 &lt;template&gt; &lt;div&gt; &#123;&#123;html&#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Bus from '@/common/bus.js' export default &#123; data () &#123; return &#123; html: '还没有点击' &#125; &#125;, created () &#123; Bus.$on('getTarget', index =&gt; &#123; this.html = `第$&#123;index&#125;个元素` &#125;) //this.$on('global: getTarget', index =&gt; &#123; // this.html = `第$&#123;index&#125;个元素` // &#125;) &#125; &#125; &lt;/script&gt;``` 在node中有一个 `vue-event-proxy` npm包能够实现与EventBus同样的功能，需要安装该npm包, 并且在main.js中进行`引入 ` ```js import EventProxy from 'vue-event-proxy' Vue.use(EventProxy) // 激活使用 // 完成后即可以使用上面组件中js注释部分的代码代替Bus代码]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F07%2F15%2Fsorts%2F</url>
    <content type="text"><![CDATA[算法题如下数字: 35 99 18 76 12 桶排序 有[100] for初始化数组 将数字放到相应的位置 思想： 1234567891011121314151617181920212223242526272829303132333435 利用数组的下标是有序的,待排序的数字大小在下标的范围内，当数组下标等于要排序的数组时 用待排序的数字坐桶的下标 给相应项+1 类似于做标记的 myIdea:当下标等于待排序的数字大小 即输出下标 相当于输出较小的数字 ``` **时间复杂度:** 时间复杂度 循环 O(M+N) 一重循环最大值99 100，又一重循环N， 之后又有一层循环M 有值的桶子 嵌套循环 &gt;= 0 1 2 3有限的，&lt;N M+N 多层循环是最花时间M+N O(M+N+M+N)=O(2*(M+N)) O(M+N) **缺点:** 占物理内存，因为要分配M个元素的数组 - 冒泡排序 ```js// 冒泡排序 // 思想: 比较相邻的元素。如果第一个比第二个大，就交换两数顺序 const source_arr = [35,18, 99, 18, 76, 12];function bubbleSort(arr) &#123; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 let temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(source_arr)); 选择排序 第一重循环默认把 i 个作为最小值与后面 j 循环中的的数进行比较，也就是通过第二重循环与后面的值进行比较 12345678910111213141516171819202122// n^2// 找到数组中最小的值放在第一位，第二小的放在第二位...// 基址查询function SelectSort(arr) &#123; let len = arr.length for(let i = 0; i &lt; len; i++) &#123; let minIndex = i // 如果已经选择了， 前面的就一定是有序的 for( let j = i; j &lt; len; j++) &#123; if( arr[j] &lt; arr[minIndex]) &#123; // 循环和默认的最小值进行比较， 如果更小纪录下标 minIndex = j console.log(i, j) &#125; &#125; if(minIndex !== i) &#123; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]] &#125; &#125; return arr&#125;console.log(SelectSort([45,21,45,12,56,12,67,32,98])) 快排排序 因为采用了分治思想，所以快 形象的例子 三个数之间进行排序 a b c 再加递归 123456789101112131415161718192021222324252627 // 简单排序： 冒泡、选择、插入 时间复杂度都是 n^2 // 复杂排序： 快排、堆排、归并排序 时间复杂度都是 (log2^n)* n // 分治 // 快排 log2(n)* n for循环 n次 // 1. 随机选择一个数组中的一个数作为一个基准 一般是中点 // 2. 其余数字跟他比较， 小的放左边 大的放右边 // 3. 利用递归的思想， 将左右两边的数重复以上两步function QuickSort(arr) &#123; // 这里是出口 当数组长度小于等于1的时候结束递归 if(arr.length &lt;= 1) &#123; return arr &#125; let pivotIndex = Math.floor(arr.length /2) // 把中间基准值从数组提出来 pivot = arr.splice(pivotIndex, 1)[0] // 选出相应位置的值 console.log(pivot) let left = [], right = [] for(let i = 0, len = arr.length ; i &lt; len; i++) &#123; if( arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return QuickSort(left).concat(pivot, QuickSort(right))&#125;console.log(QuickSort([85, 24, 63, 45, 17, 31, 78, 56]))]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【轻松集赞】写了个涉嫌混淆微信官方服务的小程序]]></title>
    <url>%2F2018%2F06%2F13%2FthumbsUp%2F</url>
    <content type="text"><![CDATA[发生背景：&nbsp;&nbsp;&nbsp;&nbsp;随着现在国内的社交软件用户群体的不断扩大，商家打广告的方式（套路）也越来越多了，每次走在大街上都可以看到商家打出来广告牌，”朋友圈点赞超过30享受六折优惠”。在上一次和女盆友出去万达吃个晚饭，终于我们也被这个活动诱惑了一下下，作为口袋钱不多又想好好吃一顿的大三狗，看看望着桌子上一大盆烤鱼，还在犹豫要不要点一份小龙虾的女朋友，还是选择了拍照发朋友圈然后挨个去群里叫亲朋好友点赞，麻烦了一堆好友，真是不好意思。&nbsp;&nbsp;&nbsp;&nbsp;吃饱喝足，两个人扶着腰走在路上炫’腹’、还是女盆友的提醒说，你不是会小程序吗，能不能写一个点赞的小程序来用。哎、还真是，我自己撸一个，说不定还能给其他人用。 初局雏形分析了一下小程序要的功能：1. 主要功能：点赞（想要多少赞就要多少赞） 2. 微信朋友圈部分功能 项目结构感觉这个小程序比较适合想要练手小程序和WeUI的盆友，所以细讲一点123456789&gt;├── assets 小程序所需的images icon ├── pages 页面目录 | ├── welcome 欢迎页面 | ├── index 内容发布操作页面| ├── mian &apos;朋友圈&apos; ├── style 页面的样式 及weui└── app.js 小程序逻辑 全局参数└── app.wxss 小程序公共样式└── app.json 项目的配置 需要注意的地方：微信朋友圈发布一张图片和多张图片图片宽高比例不一样 欢迎页面Welcome欢迎页的动画我很喜欢，也许是这一个小程序的亮点 各位，请原谅我、我也不知道怎么就变成横向的了 写在后面 小程序在模拟器上实现一些复杂功能和界面效果时，及时在移动设备上进行效果查看， 避免移动端上达不到预期效果，ios和android有时候在样式的显示上有时也会有不同]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC 浅谈]]></title>
    <url>%2F2018%2F06%2F13%2FBFC%2F</url>
    <content type="text"><![CDATA[写在前面 Block formatting context （块级格式化上下文） 页面文档由块block构成 每个block在页面上占据自己的位置使用新的元素构建BFC overflow：hidden | auto | scroll； 只要不为visible新的空间告诉浏览器，外面的环境影响不到我了 我重新来进行Block formatting 布局和定位 核心： 新的BFC，给出了新的不受外界影响的块级格式化环境 block 块级-&gt; 页面的基础 formatting context 格式化-&gt; 渲染 浏览器构建文档树的时候 布局和定位元素网页的定位（大） 文档流正常，浮动，定位，flex，table广义的定位 块级元素的定位 垂直的定位；行内元素 左右定位 通过内容来确定狭义的定位：float 浮动元素，在一行的开始或者结束flex 弹性布局position BFC 在正常的文档流里面重建一个新的上下文环境 BFC的约束规则 一、在浏览器进行页面元素布局的时候 同一个BFC的两个相邻的Box的margin 会重叠，与方向无关 破坏规则 创建新的BFC Context上下文的概念 如何创建BFC？=&gt;重新规划一个（独立）渲染区域 根元素body，天然是一个BFC overflow:hidden; float 不为none display:inline-block | table-cell |table-caption position:absolute | fixed 只要不为static 好像只剩块级元素和行内元素不是BFC 二、BFC的高度，浮动元素也要参与计算 在元素float之后脱离了文档流没有办法计算确切高度，这种情况我们称之为高度塌陷。解决高度塌陷的前提就是能识别并包含到浮动元素。而BFC就有这个特性，所以BFC也可以计算浮动元素的高度。新建BFC让浮动元素也参与计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 &lt;style&gt; *&#123;padding: 0;margin: 0;&#125; .par&#123; border: 5px solid #fcc; width: 300px; /*这里的overflow并不是为了超出则隐藏，而是为了创建一个BFC*/ /* overflow: hidden; */ display: inline-block; &#125; .child&#123; border: 5px solid #f66; width: 100px; height: 100px; float: left; /* clear: both; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 网页的定位（大） 文档流正常，浮动，定位，flex，table --&gt; &lt;div class="par"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;``` - 三、每个元素的左边，要与包含盒子的左边相接触- 四、BFC的区域不会与float box重叠 ```html &lt;style&gt; *&#123;padding: 0;margin: 0;&#125; .aside&#123; float: left; width: 100px; height: 150px; background-color: #ff6666; &#125; .main&#123; height: 200px; background: #ffcccc; /* clear: left; */ overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自适应两栏式布局 类似于flex：1； aside 和 main 处于同一BFC（body）下 BFC布局规则3 规则4 --&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/body&gt;``` ```html/*BFC在三栏式布局中的应用*/ &lt;style&gt; *&#123;padding: 0;margin: 0;&#125; .container&#123; height: 200px; &#125; .left,.right,.center&#123; height: 200px; &#125; .left&#123; background: pink; float: left; width: 180px; &#125; .right&#123; background: lightblue; width: 180px; float: right; &#125; .center&#123; background: yellow; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 三栏式布局 --&gt; &lt;div class="container"&gt; &lt;!-- 页面的结构与呈现效果不一致？想一下 --&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right&lt;/div&gt; &lt;div class="center"&gt;Center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;``` **注意：** &gt; 通过 overflow:hidden将元素转换为BFC，固然可以解决高度塌陷的问题，但是大范围的应用在布局上是肯定是行不通的，毕竟overflow会造成溢出隐藏的问题，特别是与JS交互的效果时。 那有没有一个更好的高度检测方法呢？答案是有的，就是我们经常用到的clearfix。 ```css.clearfix:after&#123; content:''; display:table; clear:both&#125;.clearfix&#123; *zoom:1;/* IE6,7不支持BFC，所以需要通过专有的CSS属性，触发hasLayout。*/&#125; 关于zoom:1]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何手动实现一个New操作]]></title>
    <url>%2F2018%2F06%2F13%2Fnew%2F</url>
    <content type="text"><![CDATA[写在前面 在所有的前端面试中常常喜欢考面试者如何手写一个new操作符，作为在准备秋招的大三党，我也要考虑这些。那么我们先看看new操作符都干了什么事情，有哪些操作？通过下面的代码来进行思考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 新建一个类（构造函数）function Otaku(name, age) &#123; this.name = name; this.age = age; // 自身的属性 this.habit = 'pk';&#125;// 给类的原型上添加属性和方法Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;// 实例化一个person对象const person = new Otaku('乔峰',5000);person.sayYourName();console.log(person);//打印出构造出来的实例``` ![控制台打印结果](http://p9utic4op.bkt.clouddn.com/new.png) ## 解析 从控制台打印出来的结果我们可以看出new操作符大概做了一下几件事情： 1. 返回（产生）了一个新的对象 2. 访问到了类Otaku构造函数里的属性 3. 访问到Otaku原型上的属性和方法 并且设置了this的指向（指向新生成的实例对象） 通过上面的分析展示，可以知道new团伙里面一定有Object的参与，不然对象的产生就有点说不清了。 先来边写写： ```js// 需要返回一个对象 借助函数来实现new操作 // 传入需要的参数： 类 + 属性const person = new Otaku('乔峰',5000);const person1 = objectFactory(Otaku, '鸠摩智', 5000);// 开始来实现objectFactory 方法 function objectFactory(obj, name, age) &#123;&#125;// 这种方法将自身写死了 如此他只能构造以obj为原型，并且只有name 和 age 属性的 obj// 在js中 函数因为arguments 使得函数参数的写法异常灵活，在函数内部可以通过arguments来获得函数的参数function objectFactory() &#123; console.log(arguements); //&#123; '0': [Function: Otaku], '1': '鸠摩智', '2': 5000 &#125; // 通过arguments类数组打印出的结果，我们可以看到其中包含了构造函数以及我们调用objectfactory时传入的其他参数 // 接下来就是要想如何得到其中这个构造函数和其他的参数 // 由于arguments是类数组，没有直接的方法可以供其使用，我们可以有以下两种方法: // 1. Array.from(arguments).shift(); //转换成数组 使用数组的方法shift将第一项弹出 // 2.[].shift().call(arguments); // 通过call() 让arguments能够借用shift方法 const Constructor = [].shift.call(arguments); const args = arguments; // 新建一个空对象 纯洁无邪 let obj = new Object(); // 接下来的想法 给obj这个新生对象的原型指向它的构造函数的原型 // 给构造函数传入属性，注意：构造函数的this属性 // 参数传进Constructor对obj的属性赋值，this要指向obj对象 // 在Coustructor内部手动指定函数执行时的this 使用call、apply实现 Constructor.call(obj,...args); return obj;&#125;``` - 上面的代码注释太多，剔除注释以后的代码：```js function objectFactory() &#123; let Constructor = [].shift.call(arguments); const obj = new Object(); obj.__proto__ = Conctructor.prototype; Constructor.call(obj,...arguments); return obj; &#125;``` - 还有另外一种操作： ```jsfunction myNew(Obj,...args)&#123; var obj = Object.create(Obj.prototype);//使用指定的原型对象及其属性去创建一个新的对象 Obj.apply(obj,args); // 绑定 this 到obj, 设置 obj 的属性 return obj; // 返回实例&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WePY 上手]]></title>
    <url>%2F2018%2F06%2F04%2Fwepy%2F</url>
    <content type="text"><![CDATA[来自微信官方的小程序组件开发框架介绍WePY (发音: /&apos;wepi/)是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。 类Vue开发风格 支持自定义组件开发 支持引入NPM包 支持Promise 支持ES2015+特性，如Async Functions 支持多种编译器，Less/Sass/Stylus/PostCSS、Babel/Typescript、Pug 支持多种插件处理，文件压缩，图片压缩，内容替换等 支持 Sourcemap，ESLint等 小程序细节优化，如请求列队，事件优化等 安装使用安装（更新）wepy命令行工具1npm install wepy-cli -g 生成开发实例1234567891011121314npm init standard projectName``` 生成src的目录 开发在此目录进行开发### 安装依赖 ```jsnpm install``` 将所有项目和开发时（package.json）所需要的依赖进行安装### 开启实时编译```jswepy build --watch``` 生成dist目录、并实时监听src目录下的修改且编译到dist目录中 ### WePY项目目录结构 ├── dist 小程序运行代码目录（该目录由WePY的build指令自动编译生成，请不要直接修改该目录下的文件）├── node_modules├── src 代码编写的目录（该目录为使用WePY后的开发目录）| ├── components WePY组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy 可复用的WePY组件a| | └── com_b.wpy 可复用的WePY组件b| ├── pages WePY页面目录（属于完整页面）| | ├── index.wpy index页面（经build后，会在dist目录下的pages目录生成index.js、index.json、index.wxml和index.wxss文件）| | └── other.wpy other页面（经build后，会在dist目录下的pages目录生成other.js、other.json、other.wxml和other.wxss文件）| └── app.wpy 小程序配置项（全局数据、样式、声明钩子等；经build后，会在dist目录下生成app.js、app.json和app.wxss文件）└── package.json 项目的package配置` 开发者工具导入项目使用微信开发者工具新建项目，本地开发选择生成的dist目录，会自动导入项目目录配置 WePY官方文档]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序笔记总结]]></title>
    <url>%2F2018%2F05%2F16%2FwxNote%2F</url>
    <content type="text"><![CDATA[小程序的项目架构 基础组件 地图 视图容器 组件 事件数据绑定template 只支持wxml wxss 模板 模块化不支持wx:for wx:key wx:if样式导入 和 模块引入数据缓存// 设置缓存 缓存是永久存在的 没有时效 上限最大不能超过10M // wx.setStorageSync (&quot;collect&quot;, true); // 修改缓存，同名 wx.setStorageSync(&apos;key&apos;,{ game:&quot;风暴英雄&quot;, developer:&apos;暴雪&apos; }); // var postCollected=wx.getStorageSync(&quot;collected&quot;); }, collectionTap(event){ let game = wx.getStorageSync(‘key’); console.log(game.developer); }, shareTap(event){ // wx.removeStorageSync(‘key’); // 清除所有缓存 wx.clearStorageSync(); },]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>WXApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus之变量与mixin]]></title>
    <url>%2F2018%2F05%2F09%2Fmixin%2F</url>
    <content type="text"><![CDATA[混合书写(Mixins) 变量 在stylus中 可以将常用的样式像表达式中变量赋值一样保存给一个变量、如下： 12345678/*进行变量的声明*/bg_color = #123456;box_size = 100px;/* 使用 */.box background-color bg_color width box_size height box_size 编译后： 12345.box &#123; background-color: #123456; width: 100px; height: 100px; &#125; 属性查找Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下： 12345678#logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2) 在stylus中可以不使用这里的变量w和h, 而是简单地前置@字符在属性名前来访问该属性名对应的值：12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 混合书写 混合书写和函数定义方法一致，但是应用却大相径庭。 例如，在书写Css3样式时我们经常要进行兼容性处理，需要在属性前加上相应的前缀，下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。123456789101112131415161718192021222324 bg_color = #123456; box_size = 100px; /*定义mixin*/ border-radius(n) -webkit-border-radius n -moz-border-radius n -ms-border-radius n -o-border-radius n border-radius n .box background-color bg_color width box_size height box_size border-radius(5px)``` 进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式,这样就可以給属性传递多个值。 ```cssborder-radius() -webkit-border-radius arguments -moz-border-radius arguments -ms-border-radius arguments -o-border-radius arguments border-radius arguments Stylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。例如，-webkit-{‘border’ + ‘-radius’}等同于-webkit-border-radius. 再进一步，在stylus中我们还可以对border-radius再做进一步的处理 类似与js中的函数封装 ，如下(这样对于任何需要做兼容性处理的属性 我们只需要调用两次mixin出入所需参数，大大的简化了一下琐碎代码工作): 12345678910111213141516 vendor(prop,args) -webkit-&#123;prop&#125; args -moz-&#123;prop&#125; args -ms-&#123;prop&#125; args -o-&#123;prop&#125; args &#123;prop&#125; argsborder-radius(n) vendor('border-radius',arguments)box-shadow(n) vendor('boa-shadow',arguments).box background-color bg_color width box_size height box_size border-radius(5px) 编译后： 123456789101112131415 .box &#123; background-color: #123456; width: 100px; height: 100px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; -webkit-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); -moz-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); -ms-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); -o-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); box-shadow: 1px 1px 10px rgba(0,0,0,0.5);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让div在屏幕上居中（水平居中+垂直居中）的方法总结]]></title>
    <url>%2F2018%2F05%2F09%2FcssCenter%2F</url>
    <content type="text"><![CDATA[html代码如下： &lt;div class="book"&gt; &lt;div class="front-cover"&gt; &lt;/div&gt; &lt;/div&gt; CSS居中方法 （敲黑板）重点 首先将元素设置成为绝对定位，然后距顶部和左各50%，此时的元素还不是居中的，因此需要通过一定的偏移将其移到理想位置，两种方法的主要思想都是一样的，第一种通过margin-left和margin-top移动元素自身宽高的一半，另一种通过css3的属性transform的translate方法平移元素自身宽高的一半， 代码展示如下： body { color: #ffffff; background: #444444; } .book { width: 300px; height: 300px; position: absolute; top: 50%; left: 50%; /* 第一种 */ /* 兼容性 未使用css3, ie678 */ /* margin-left: -150px; */ /* margin-top: -150px; */ /*第二种*/ -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); } 两种方法第一种的兼容性更加的好一些，因为其中没有使用Css3的属性 对于ie678的兼容比较友好]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F05%2F09%2FURL%2F</url>
    <content type="text"><![CDATA[title: 输入URL之后date: 2018-05-03tags: HTTP categories: 前端有的研究]]></content>
  </entry>
  <entry>
    <title><![CDATA[LazyLoad(懒加载)]]></title>
    <url>%2F2018%2F05%2F04%2FLazyLoadImage%2F</url>
    <content type="text"><![CDATA[src里面做文章节省http请求数量]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3属性]]></title>
    <url>%2F2018%2F05%2F04%2FCss3%2F</url>
    <content type="text"><![CDATA[text-shadow属性介绍: text-shadow属性可以给页面上的文字增添阴影效果，text-shadow在Css2.1的时候是 被删除了的一个属性，但是呢在3.0的Css中又恢复了使用 使用方法1text-shadow : length length length color 注：前两个参数在使用的时候必须给定 第一个length表示阴影离开文字横方向的距离 第二个length表示阴影离开文字纵方向的距离 第二个length表示阴影模糊半径 即模糊范围 color 表示阴影颜色 可以放在三个length之前 也可以放在之后 如果不给值 则使用元素默认color $ 指定多个阴影： 每个阴影用逗号隔开 1text-shadow : 15px 15px 5px #000,30px,30px,5px #f60; background-size属性介绍: 在Css3中可以使用background-size来指定背景图像的尺寸 使用方法 1background-size: auto || length || percentage || cover || contain auto: 默认值 保持背景图片的原始宽高比 length: 设置背景图片的宽度和高度，如果只设置一个值，则第二个值会被设置为auto 按宽高比进行放大缩小 percentage: 以父元素的百分比来设置宽度和高度，如果只设置一个值 同上 cover: 此值是将图片放大，以适合铺满整个容器，这个主要用在当图片小于容器又无法使用background-repeat来实现，就采用cover将背景图片放大到适合容器的大小，但是会使图片失真 contain: 与cover相反，将背景图片缩小以适合铺满整个容器，这个主要用在当背景图片大于元素容器时，而又需要将背景全部显示出来，就可以用contain将图片缩小到适合容器的大小，这种方法同样会使图片失真 在一个元素中显示多个背景图片介绍: 在Css3一个元素可以显示多个背景图像，还可以将多个背景图像进行重叠显示，这样对背景中所用素材调整变得更加容易。 使用方法1background-image:url(1.png),url(2,png),url(3.png); 图层的排序方法: 浏览器中显示时叠放的顺序是从上往下指定的，第一个图片放在最上面，最后指定的放在下面 Css3的变形功能transform属性 介绍: 在Css3中可以利用transform属性来实现文字或图像的旋转、缩放、倾斜、和移动。但是需要做兼容性处理，如下 1234-webkit-transform: rotateX(60deg);-moz-transform: rotateX(60deg);-ms-transform: rotateX(60deg); /*IE9*/-o-transform: rotateX(60deg); rotate(旋转)： rotate(60deg);顺时针旋转 deg是Css3中的角度单位 1-webkit-transform: rotateX(60deg); rotateX(angle) rotateY(angle) rotateZ(angle) 绕对应的轴进行3D旋转 rotate3D(X,Y,Z,deg) 定义 3D 旋转 scale(缩放)：transform:scale(值) 值所指的是缩(小)放(大)倍率 如果值为负数并没有效果 纯属无聊 scale(x,y) 使元素在x轴 y轴方向同时缩放 scaleX(.5) 你应该懂得 scaleY(.5) 同上 skew(倾斜)transform:skew(deg) 倾斜角度 skew(x,y) 元素在水平和垂直方向上同时倾斜 只有一个参数时，只在水平方向上倾斜 skewX(x) 元素仅在水平方向倾斜 skewY(y) 元素在垂直方向倾斜 translate(值) 指定移动的距离 负值即反方向移动 translate(x,y);在x轴和y轴同时移动，只有一个参数时，仅在水平方向移动; translateX(x);x轴方向移动-translateY(y);y轴方向移动 transform-origin 改变元素基点 属性使用：transform-origin:bottom; 各个基点参考如图： 对一个元素使用多种变形的方法： transform：方法一，方法二，方法三..; 12 /*同样也需要做兼容性处理*/transform: translate(50px),rotate(60deg),scale(2); Css3的动画功能demo transition 支持从一个属性平滑过渡到另外一个属性 语法: 1transition: property duration timing-function delay; transition 主要包含四个属性值: 执行变换的属性: transition-property,属性规定应用过渡效果的CSS属性的名称。(当指定的CSS属性改变时，过渡效果将开始)值有三个类型: A、none 没有属性会获得过渡效果。B、all所有属性都将获得过渡效果。C、property定义应用过渡效果的CSS 属性名称列表，列表以逗号分隔。 变换延续的时间: transition-duration规定完成过渡效果需妻花费的时间(以秒或毫秒计》，默认值0没有效果 在延续时间段，变换的速率变化transition-timing-function值: 123456A. ease: (逐渐变慢) 默认值，ease函数等同于贝塞尔曲线(0.25,0.1,0.25,1.0). B. linear: (匀速)，linear 函数等同于贝塞尔曲线(0.0,0.0,1.0,1.0). C. ease-in: (加速)，ease-in 函数等同于贝塞尔曲线(0.42,0,1.0,1.0). D. ease-out: (减速)，ease-out 函数等同于贝塞尔曲线(0,0,0.58,1.0). E. ease-in-out : (加速然后减速)，ease-in-out 函数等同于贝塞尔曲线(0.42,0,0.58,1.0) F. cubic-bezier(n,n,n,n)在cubic-bezier 函数中定义自己的值。可能的值是0 至1之间的数值。 animation 支持通过关键帧的指定来在页面上产生更复杂的动画效果 用 transition和Animations的区别 : transition和Animations的区别在于，transition只能通过指定属性的开始值与结束值，然后通过两属性值之间进行垂滑过渡的方式来实现动画效果，所以transition不能实现复杂的动画效果，而Animations功能是是通过关键幀以及每个关键帧中的属性值来实现更为复杂的动画效果。 Animations的使用方法:参考我的飞机Demo更好哦 123456789101112131415161718@-webkit-keyframes 关键帧合集名称&#123; 创建关键帧的代码 &#125; 0%~100%&#123; 本关键帧中的样式 &#125; // 关键帧创建好了之后，还要在元素的样式中使用该关键帧。方法如下: 元素&#123; - webkit-animation-name :关键帧合集名称 ; - webkit-animation-duration:5s ; - webkit-animation-timing-function :linear;-webkit-animation-iteration-count:infnite &#125;```css -webkit-animation-name 指定合集名称， -webkit-animation-duration 整个动画执行完成需要的时间， -webkit-animation-timing-function 实现动画的方法 -webkit-animation-iteration-count 属性的属性值设定为某个整数值，那么这个动画播放的次数就等于这个整数值(infinite是无限循环播放)。 实现动画的方式: A、linear: 匀速进行. B、ease-in: 开始速度很慢，然后沿曲线进行加快， C、ease-out: 开始速度很快，然后沿着曲线进行减速. D、ease: 开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速， E、ease-in-out: 开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速. 也可以以合集的形式进行样式书写：1animation: name duration timing-function delay iteration-count direction;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$(document).ready()与window.onload]]></title>
    <url>%2F2018%2F05%2F03%2Fjquery%2F</url>
    <content type="text"><![CDATA[早点写]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完整的URL请求页面过程]]></title>
    <url>%2F2018%2F05%2F03%2FURL2%2F</url>
    <content type="text"><![CDATA[当我们在网页浏览器（Web browser）的地址栏中输入URL时，Web页面是如何呈现的？就让我们来聊聊从用户输入到页面加载完成的过程中都发生了什么事情。 一、请求过程简介用户输入URL大概发生了以下一些事： (1) DNS域名解析到对应的IP地址； (2) 浏览器向Web服务器发送一个HTTP请求； (3) 服务器的永久重定向响应; (4) 浏览器跟踪重定向地址; (5) 服务器处理请求，并返回一个HTTP响应; (6) 浏览器显示HTML;[1]: 请求过程 二、请求过程详解1. DNS查找IP地址DNS是域名系统（Domain Name System）的缩写，是因特网的一项核心服务，是和HTTP协议位于应用层的协议，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 (一) DNS 查找过程 浏览器缓存 – 浏览器会缓存DNS记录一段时间，但是操作系统并没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。 系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。 路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。 ISP DNS缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。 递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从.com顶级域名服务器到example的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。 (二) DNS进行域名解析的过程 客户端发出 DNS 请求翻译 IP 地址或主机名； DNS 服务器在收到客户端的请求后，检查 DNS 服务器的缓存，若查到请求的地址或名字，即向客户端发出应答信息； 若没有查到，则在数据库中查找，若查到请求的地址或名字，即向客户端发出应答信息； 若没有查到，则将请求发给根域 DNS 服务器，并依序从根域查找顶级域，由顶级查找二级域，二级域查找三级，直至找到要解析的地址或名字。然后，向客户端所在网络的 DNS 服务器发出应答信息，DNS 服务器收到应答后，先在缓存中存储，然后，将解析结果发给客户端。 若没有找到，则返回错误信息。 2. HTTP请求 (一) 三次握手建立TCP连接 在 http 工作开始之前，浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的。该协议与 IP 协议共同构建 Internet ，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。http 是比 TCP 更高层次的应用层协议。根据规则，只有低层协议建立之后才能进行更高次层协议的连接。因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80 。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接： 1. 第一次握手：建立连接时，客户端发送 SYN 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers） 2. 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； 3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，完成三次握手。 (二) 完成三次握手，客户端与服务器开始传送数据。 一旦建立了 TCP 连接，浏览器就会向服务器发送 http 请求命令。浏览器发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息。此后，浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。[4]: 完成三次握手 (三) 四次挥手终止连接 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动。一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 1. 第一次挥手：TCP 客户端发送一个 FIN，用来关闭客户端到服务器的数据传送（客户端向服务器发送一个断开连接的请求）; 2. 第二次挥手：服务器收到这个 FIN，它发回一个 ACK（确认收到请求的信号），确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号 (服务器接收到请求之后，发送确认接受到请求的信号); 3. 第三次挥手：服务器关闭客户端的连接，发送一个 FIN 给客户端 (服务器向客户端发送断开的通知); 4. 第四次挥手：客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1 (客户端接收到断开的通知后断开连接，并反馈一个确认信号，服务器接收到确认信号断开连接)。 3. 服务器的永久重定向响应服务器会给浏览器返回一个301永久重定向响应服务器给浏览器响应一个 301 永久重定向响应，这样浏览器就会访问http://www.facebook.com/ 而非 http://facebook.com/ 。为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。你看，如果一个页面有两个地址，就像 http://www.igoro.com/ 和 http://igoro.com/ ，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道 301 永久重定向是什么意思，这样就会把访问带 www 的和不带 www 的地址归到同一个网站排名下。还有一个原因是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。 4. 浏览器跟踪重定向地址浏览器通过 301 知道 http://www.facebook.com 才是要访问的正确地址，所以它会发送另一个获取请求。 5. 服务器处理请求，并返回一个HTTP响应服务器接收到获取请求并处理，然后返回一个HTTP响应 6. 页面渲染现代浏览器渲染页面的过程是这样的：解析 html 以构建 DOM 树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树DOM 树是由 html 文件中的标签排列组成。 渲染树是在 DOM 树中加入 css 或 html 中的 style 样式而形成。渲染树只包含需要显示在页面中的 DOM 元素，像 &lt;head&gt;元素或 display 属性值为 none 的元素都不在渲染树中。在浏览器还没接收到完整的 html 文件时，它就开始渲染页面了。 在遇到外部链入的脚本标签、样式标签、图片时，会再次发送 http 请求重复上述的步骤。在收到 css 文件后，会对已经渲染的页面重新渲染，加入它们应有的样式。图片文件加载完，立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。]]></content>
      <tags>
        <tag>面试</tag>
        <tag>🌝</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css3之Flex布局]]></title>
    <url>%2F2018%2F05%2F02%2Fflexbox%2F</url>
    <content type="text"><![CDATA[Flex(flexible box) 弹性布局传统的布局解决方案，基于盒模型，通过 css中的display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 概念 任何容器都可以设为flex布局 采用flex布局的元素即为flex container，其子元素为容器成员(flex item) 设为flex布局以后，子元素的float/clear/vertical-align属性将会失效 主轴和交叉轴 容器默认存在水平主轴main axis和垂直的交叉轴cross axis flex-item排列的方向是主轴 flex-container容器属性 flex-direction决定主轴的方向(同时也是flex-item的排列方向) flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴是水平方向，flex-item水平从左往右排列 column : 主轴呈垂直方向,从上边沿向下排列 reverse参数: 将起始与终点进行互换 flex-wrap 属性定义如果在一条轴线上排不下，换行的规则 flex-wrap：nowrap | wrap | wrap-reverse nowrap（默认值）：不换行 wrap : 自然换行 直接将多余的元素从下一行开始排列 wrap-reverse: 将第一行排列到下方 flex-flow 是flex-direction和flex-wrap的简写，默认值为row nowrap justify-content:定义flex-item在主轴main-axis上的对齐方式 justify-content: flex-start | flex-end | center | space-between | space-around flex-start（默认值）：左对齐； flex-end右对齐； center居中； space-between：两端对其，flex-item间的间隔距离相等 space-around：每个flex-item两侧的间隔相等，相当于设置左右margin值相等 align-items: 定义flex-item在交叉轴的对齐方式 align-items: flex-start | flex-end | center | baseline | strecth。五个取值与交叉轴方向有关 flex-start|flex-end|center和flex-direction一样，只不过是在交叉轴起点、终点、中点对齐； baseline：flex-item的第一行文字的基线对齐 stretch（默认值）：如果flex-item没有设置高度或者值为auto，将占满整个容器高度 align-content：如果容器内出现多跟轴线（即出现wrap），定义主轴在交叉轴上的对齐方式，只有一根轴线时不起作用 align-content: flex-start | flex-end | center | space-between | space-around | stretch stretch（默认值）：轴线沾满整个交叉轴 space-between：与交叉轴两端对齐，轴线间的间隔平均分布 space-around：每根轴线两侧的间隔相等 flex-start：与交叉轴起点对其 flex-item项目的属性 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大.&nbsp; &nbsp; &nbsp;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。负值对该属性无效。 flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] flex-basis align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript函数]]></title>
    <url>%2F2018%2F05%2F01%2Ffunction_note%2F</url>
    <content type="text"><![CDATA[函数 函数用于指定对象的行为，在其中包含一组语句。用于代码复用、信息隐藏、和组合调用。 函数对象JavaScript 中的函数就是对象。函数对象连接到Function.prototype（该原型对象本身连接到Object.prototype）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。 函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值即为该函数对象。1234567891011121314151617181920212223242526272829 function add(a,b)&#123; return a+b; &#125;``` 因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。函数的与众不同之处在于可以被调用。 ### 函数字面量 函数对象通过函数字面量来创建。函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。```js var add = function(a, b) &#123; return a + b &#125; ``` ### 调用 调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：`this`和`arguments`。参数this在面向对象编程中非常重要，它的值取决于调用的模式。实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为undefined。 - 方法调用模式 当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，`this被绑定到该对象`,通过this可以对该对象的属性和方法进行调用和操作。 ```js var myObject = &#123; text: hello, say:function(msg)&#123; console.log(this.text + msg); &#125; &#125; myObject.say(world); 函数调用模式当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。此时this被绑定到全局对象。即时是内部函数也会将this绑定到全局对象。this的指向问题 作用域不一样 this的指向就不一样,可以在函数内创建一个属性并赋值为this来解决这个问题,一般通过var that = this; 1234567891011121314var add = function(a, b) &#123; return a + b&#125;myObject.double = function() &#123; var that = this var helper = function() &#123; that.value = add(that.value, that.value) &#125; helper()&#125;myObject.double()console.log(myObject.value) //8 12345678910111213141516171819202122232425 attachEvent: function () &#123; // attachEvent函数的作用域 // js 里面this总会指向什么 // 对象的方法被执行时 this指向对象 // console.log(this); var that = this; this.staticElement.addEventListener('click', function () &#123; // 这个函数被执行时，并不是对象的方法，而是匿名函数，作为事件处理函数来执行，this会指向事件发生元素 // this的指向跟函数的调用方式有关 // this的指向问题 作用域不一样 this的指向就不一样 // 作用域 事件的回调函数 // console.log(this); // alert(that.value); that.convertToEdit(); &#125;, false); this.filedElement.addEventListener('keydown', function (evt) &#123; // 在事件发生的一刹那 会产生一个临时事件对象 console.log(evt); if (evt.keyCode == 13) &#123; that.staticElement.innerHTML = this.value; console.log(that.staticElement.innerHTML); that.convertToText(); &#125; &#125;, false)&#125; 构造器调用模式JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。如果在一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。 1234567891011121314//创建构造器函数var Quo = function(string) &#123; this.status = string&#125;//给Que的所有实例提供一个公共方法Quo.prototype.getStatus = function() &#123; return this.status&#125;//实例化var myQuo = new Quo('confused')console.log(myQuo.getStatus()) //confused Apply 调用模式apply方法让我们构建一个参数数组传递给调用函数。他也允许我们选择this的值。apply方法接受两个参数，第一个是要绑定给this的值，第二个是参数数组。 123456789101112131415161718192021222324 var arr = [3, 4] var sum = add.apply(null, arr) console.log(sum) //7 var statusObject = &#123; status: 'hello' &#125; var status = Quo.prototype.getStatus.apply(statusObject) console.log(status) //hello``` ### 参数 当函数被调用时，会得到一个`arguments`数组。通过此参数可以访问所有它被调用时传递给它的`参数列表`，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。```js var sum = function() &#123; var i, sum = 0 for (i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; return sum &#125; console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)//45 因语言的设计错误，arguments并不是一个真正的数组。是一个“类似数组”的对象。有length属性，但没有任何数组的方法。 返回函数执行时遇到关闭函数体的}时结束。然后把控制权交还给调用该函数的程序。 return可以使函数提前返回，当return语句执行时函数立即返回不在执行余下的语句。 函数总是会返回一个值，若没有指定，则返回undefined。 若函数调用时在前面加上了new前缀，且返回值不是一个对象的时候，则返回this（该新对象）。 闭包作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了this和arguments）。12345678910var quo = function(status) &#123; return &#123; get_status: function() &#123; return status; &#125; &#125;&#125;var myQuo = quo('amazed')console.log(myQuo.get_status()) //amazed 狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。status访问的就说对象中的status属性本身,通过闭包可以让一个局部变量驻留在内存中 避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前i值的函数，这样就不会导致混淆了。 回调将一个函数作为参数，一旦接收到响应，再调用这个函数。12345 fs.readFile('demo/02.js','utf8',(error,data)=&gt;&#123; if(error) throw error; //在异步中的错误不能被捕获 通过throw error进行错误的捕获 console.log(data) &gt;&gt;a.txt;&#125;); 模块可以用函数和闭包构造模块。模块是一个提供接口却隐藏与实现的函数或者对象 模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。123456789101112131415161718192021var numberCal = (function() &#123; var half = function(n) &#123; return n / 2 &#125; var double = function(n) &#123; return n * 2 &#125; var tribble = function(n) &#123; return n * 3 &#125; return &#123; half: half, double: double, tribble: tribble &#125;&#125;())console.log(numberCal.half(5)) //2.5console.log(numberCal.half(6)) //3console.log(numberCal.double(7)) //14console.log(numberCal.tribble(7)) //21 级联如果让方法返回this而不是默认的undefined，就可以启用级联，即连续调用。 记忆函数可以将先前操作的结果记录在某个对象或者数组里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。]]></content>
      <categories>
        <category>JS语言精粹</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题个性化配置]]></title>
    <url>%2F2018%2F04%2F26%2Fnextconfig%2F</url>
    <content type="text"><![CDATA[看到一些大神的next博客站点很酷 那到底是怎么实现的呢 经过一番的倒腾，终于将一些使用且比较酷的功能添加到自己的博客中 主要添加的功能有： 在右上角或者左上角实现fork me on github 添加RSS· 添加动态背景· 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 主页文章添加阴影效果 在网站底部加上访问量 添加菜单分类页面· 首页实现文章内容截断（展示阅读全文） 网站底部字数统计 添加 README.md 文件· 隐藏网页底部powered By Hexo / 强力驱动 添加来必力评论 Livere· DaoVoice 在线联系 添加站内搜索0 实现fork me on github 1.修改头像并配置头像样式 编辑 ·主题配置文件·， 修改字段 `avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 将头像图片放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 或者使用图片的在线地址 2.设置博客背景动画NexT 自带两种背景动画效果：编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：如下、 #canvas_nest canvas_nest: true //开启动画 #three_waves three_waves: false //关闭动画 3.添加RSS在blog目录下安装hexo-generate-feed 然后打开z主题配置文件,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) #Set rss to false to disable feed link. #Leave rss as empty to use site&apos;s feed link. # Set rss to specific value if you have burned your feed already. rss: /atom.xml 4.在网站底部加上访问量 有点不想写了 5.网站底部字数统计&nbsp; 修改如下部分 #Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 在适当的位置添加以下页面代码 6.添加README.md 每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为skip_render:README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 7.添加菜单分类/标签页面&nbsp; 在hexo站点目录下 使用hexo new page 新建一个页面 命名为tags 如下： hexo new page tags 此时会在hexo &gt; source文件夹中会生成一个tags文件夹。 编辑tags文件夹下面的.md文件 &nbsp; 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: menu:home: / || homearchives: /archives/ || archivetags: /tags/ || tags &nbsp; 注：||之前的值是目标链接，之后的是页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。 8.添加livere来必力评论模块注意：最新版 hexo-theme-next 已经包含 LiveRe 插件，下载最新版本，配置 livere_uid 即可使用 获取livere_uid步骤 注册 LiveRe 进入 LiveRe，注册账号。 LiveRe 有两个版本： City 版：是一款适合所有人使用的免费版本；Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。City版就够了。安装，获取 uid： 填写完成后，进入到 管理页面 -&gt; 代码管理 -&gt; 一般网站 代码中，data-uid 即为所需 uid 添加 LiveRe 插件 首先在 _config.yml 文件中添加如下配置： #Support for LiveRe comments system. #You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 其中 livere_uid 即上一步获取到的 uid。其他的设置在最新版中都不需要配置啦 所以说程序员还是要用新的潮的东西 9.设置网站图标 具体方法实现 找一张（32*32）的ico图标，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改`主题配置文件`,下面就是图标配置代码修改即可： favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 10.站内博客搜索添加百度/谷歌/本地 自定义站点内容搜索. 1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： npm install hexo-generator-searchdb –save 2.编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 3.编辑 主题配置文件，启用本地搜索功能： &gt; #Local search local_search: enable: true 11.首页文章内容截断编辑主题配置文件 如下设置则会开启自动截断功能 #Automatically Excerpt. Not recommend. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo中安装next主题]]></title>
    <url>%2F2018%2F04%2F25%2Fnext_install%2F</url>
    <content type="text"><![CDATA[倒腾了一天半终于自己实现了一个还不错的博客，在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。如果没有搭建好自己的hexo+git pages博客界面可以看我另外一篇经验分享 **说明**：在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题next目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 下载主题 下载方式： 1.在theme文件夹中将主题包克隆到本地，并将文件名`hexo-theme-next`改成`next` git clone https://github.com/iissnan/hexo-theme-next themes/next 2.前往Next[发布页面][1]将`sourcecode`下载到本地，解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（`hexo-theme-next-0.4.0`）更改为 `next`。 启用Next 当 克隆/下载 完成后，打开 站点配置文件， 找到 `theme` 字段，并将其值更改为`next`。 验证主题是否应用 1. NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 最好使用 `hexo clean` 来清除 Hexo 的缓存。 2. 执行`hexo generate` 生成博客 3. 执行`hexo server`启用本地服务器 在本地可以直接查看修改以后的效果 &gt;`INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to` 使用浏览器进行访问http://0.0.0.0:4000/ 修改主题样式scheme Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 #Schemes #scheme: Mist scheme: Muse #scheme: Pisces #scheme: Gemini 其他基本配置 打开站点配置文件 可以像我一样进行基本设置 每个冒号后面必须与内容用空格分割 #Sitetitle: HeiLiu //站点titlesubtitle: 有一句Hello World想要对你说description: 程序员 大学本科keywords:author: 刘江龙language: zh-Hans //设置语言timezone: Asia/Shanghai //时间 #Deployment Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/HeiLiu/HeiLiu.github.io.git branch: master]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对数组去重的几种方法]]></title>
    <url>%2F2018%2F04%2F22%2FArrayUnique%2F</url>
    <content type="text"><![CDATA[面试经常问的一道题JS对数组去重的几种方法 (前面六种方法是普通数组，最后一种是对象数组) 方法一： 最原始的方法，定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。1234567891011121314var arr = [ 1, 1, '1', '1'];function uniqueArr(oldArr) &#123; // 新的数组 用来存放去重后的值 var newArr = []; for (var i = 0; i &lt; oldArr.length ;i++) &#123; for (var j = 0 ; j &lt; newArr.length; j++) // 如果两数相等 则跳出第二个循环 if (oldArr[i] === newArr[j]) break; // 一轮循环结束还没跳出循环 则表示此数未再新数组里出现 则加入新数组 if (j == newArr.length) newArr.push(oldArr[i]); &#125; return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1' ] 方法二： 先将数组排序，再相邻的进行比较，不同的存入新数组。（这个方法有缺陷，因为sort是按照字符编码的顺序进行排序，所以要先将数组的元素转换为字符串，来进行比较，下面的数组的这种情况就不能完美的去重。 个人认为sort方法是通过交换实现的排序，在数据量比较小的时候用的是冒泡排序，数据量比较大时用的是快速排序）1234567891011var arr = [ 1, 1, '1', '1', 1];function uniqueArr(oldArr) &#123; oldArr = oldArr.sort(); var newArr = []; for (var i = 0 ; i &lt; oldArr.length ; i++) &#123; if(oldArr[i] !== newArr[newArr.length-1]) newArr.push(oldArr[i]); &#125; return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1', 1 ] 方法三： 利用数组的indexOf下标属性来简化循环 (includes 也是一样的)12345678910var arr = [ 1, 1, '1', '1', 1];function uniqueArr(oldArr) &#123; var newArr = []; for (var i = 0 ; i &lt; oldArr.length ; i++) // 利用indexof 判断某个值是否在新的数组里面 if(newArr.indexOf(oldArr[i]) === -1) newArr.push(oldArr[i]); return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1' ] 方法四： 利用ES6的 filter 方法 加上indexOf 返回第一个item出现的位置123456789var arr = [ 1, 1, '1', '1', 1, '2'];function uniqueArr(oldArr) &#123; var newArr = oldArr.filter(function(item, index, oldArr)&#123; // indexOf 返回第一个item出现的位置 return oldArr.indexOf(item) === index; &#125;) return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1', '2' ] 方法五： 利用对象属性存在的特性，如果没有该属性则存入新数组 (这里的 1 和 ‘1’ 在用obj[]添加属性时，会被自动换成 1 然后加入进obj)1234567891011121314var arr = [ 1, 1, '1', '1', 1, '2'];function uniqueArr(oldArr) &#123; var newArr = []; var obj = &#123;&#125;; for(var i=0; i&lt;oldArr.length; i++)&#123; if( !obj[oldArr[i]] )&#123; // 属性不存在 则加入新数组 并将该属性变为 1 obj[oldArr[i]] = 1; newArr.push(oldArr[i]); &#125; &#125; return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '2' ] 方法六：利用ES6的 set 对象自动去重12345var arr = [ 1, 1, '1', '1', 1];function uniqueArr(arr) &#123; return Array.from(new Set(arr)); // 利用Array.from 将Set结构转换为数组&#125;console.log(uniqueArr(arr)); // [ 1, '1' ] Object键值对去重123456789var arr = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;];function uniqueArr(oldArr) &#123; var obj = &#123;&#125;; return oldArr.filter(function(item, index, oldArr)&#123; // 判断 obj 对象是否存在item这个属性 存在的话返回fasle 不存在的话 向Obj中添加该属性 return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;console.log(uniqueArr(arr)); // [&#123;value: 1&#125;, &#123;value: 2&#125;]]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
        <tag>🌝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 操作常用命令]]></title>
    <url>%2F2018%2F04%2F21%2FgitCommand%2F</url>
    <content type="text"><![CDATA[git所有的命令都是以git开头 后面为所要做的操作 再后面即为参数 初始化 git init 初始化后会生成.git文件 git clone URL 将URL地址下的资源clone到本地 git add . 将当前目录下面的文件提交到暂存区 git commit -m ‘你所做的修改，利于以后维护和回退’ 会得到一个指针 git push origin master 上传代码到github master分支 git branch 查看所有分支 git branch hexo 新建名为hexo的分支 git checkout hexo 切换到hexo分支 git merge 合并指定分支到当前分支 ##git合并分支&nbsp;git支持很多种工作流程，在进行合作开发时一般是这样，远程创建一个主分支，本地每人创建功能分支，日常工作流程如下： 去自己的工作分支 git checkout work 工作…. 提交工作分支的修改 git commit -a 4.回到主分支 git checkout master 5.获取远程最新的修改，此时不会产生冲突 git pull 6.回到工作分支 git checkout work 7.用rebase合并主干的修改，如果有冲突在此时解决 git rebase master 8.回到主分支 git checkout master 9.合并工作分支的修改，此时不会产生冲突。 git merge work 10.提交到远程主干 git push origin master 这样做的好处是，远程主干上的历史永远是线性的。每个人在本地分支解决冲突，不会在主干上产生冲突. 可以在一条分支上一起开发，你有变更的时候，在提交前，使用 git stash 这样将本地的修改全部缓存在一个堆栈中了，然后把别人的修改同步过来 git pull –rebase 下一步是将自己的变更恢复到最新的节点上 git stash pop 然后再使用git commit提交，这样就会让一个分支的版本按顺序继续发展]]></content>
      <categories>
        <category>Skill</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己搭建博客]]></title>
    <url>%2F2018%2F04%2F19%2Fhexo%2F</url>
    <content type="text"><![CDATA[Hexo 是开源的npm的博客包使用markdown语法写博客 结合github page 服务，有一个免费的开源博客 git配置过程 全局配置 username email ssh 在git bash中执行代码： 1. git config global user.name &quot;gitname&quot; 2.git config global user.email &quot;email&quot; 3.ssh-keygen -t rsa -C &quot;git@email&quot; 一路回车 找到.ssh文件夹 打开id_rsa.pub复制内容 4.到github上 setting 中ssh key添加 title为空 粘贴ssh至内容中 验证一下是否成功 1.在hexo目录下将 https://github.com/HeiLiu/HeiLiu.github.io.git hexo init 初始化博客 执行一下初始化命令系统会去github clone一个博客来到本地 ./node_modules是以来文件夹，npm包 项目所有依赖都在这里。3.博客存放地址 source/_post/**.md4.markdown 语法 更简捷的写html5.theme主题文件夹 hexo clean 清空生成的站点博客文件 hexo generate 博客的产生 hexo generate 将markdown语法编译成public/*.html hexo server 打开本地服务器 hexo deploy 将本地生成的public文件内容发布到github hexo 不蒜子统计不显示的问题]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[想把我唱给你听]]></title>
    <url>%2F2018%2F04%2F19%2Fheihei%2F</url>
    <content type="text"><![CDATA[加密文章，可能是个人情感宣泄或者生活记录。 4b6ac68dd98442a8df02a287190cf64599030d04c0ab3c75b9dae3cb51c4583c6abadd8d3a96ea168fde8b14cfe2ec24053d73a310c3d515bf387edc7cfdcfba02e8700c4d6bead9b3dbc317ee785d400bb19f04d3a844b2e560cbcc0cd7e6ccf3ff808a617e3d6c5cf74301efe1d9b40ab711ddca9b1daa51dba7f54dd419a93a7cebc1dda148256e6f8958c692c9eb5c9b107b348310784d3d25bce7801b404c751db623eda6cf6389f4f471f953171a4bf8603b73e1d14e2a5510a5511be97f5c1162989a20323d0f3c82ccfafd46ab5b2c05d00ca9dda49e381123b2a73b77b66397f953ccc2f6fc0900ec9f5d94ab0754fff1d92b60d18c02944e570010b0fbf90ea0f5a0eb471ca166f0a8dd84b4c4a3ebaafee1d022f0fbc56e3228716220bc135c463789afe597bd198fa32accc7f891c5914c137f1a81f9274ddb959ce6f6b046f3b77449a51e442fdc9a24831d70a835fbdfd6e43e9edea02a338770262e8a3111f518aa9373bfdc9a9097e9f80ce591de727a01bb90bf52c28f24427c4e8c7689cc481b5eee153bec4602796fab54a9ff5b31a74727eb701d994269404608cbd2cfb22424518285eecf378822af6c3612344a14aa19f6b2930216d20457089b7532989f9b28a2eea2d2485d51e57ddc256897cb508104494441e4f544ad99b5399bbaf430234e64bfb289b679c202e25eba857c17dab662be190e6a36f1c475c8a0252752941185a40b091c5e7ce02367477ed3d90bdeab70beba12f558e9ad98472d24b860b7949be9c547077dae6466942e0d01ee0c5fee2e879d01ccb7dd96da2be3f8f9aa761e5f5e990eb780c852c71bf5334bc5eb622d64c60ccec55feca53fcac821573c6f6e96a675a8ec533c3c4ead8aab3cbb7f8503864360dcea5a548250007cf475c5d299a28beaf230b566627b0200a287e09f6248b9a8e01a74c6d265745e084876dac0d32418113e2e6bb378c52b8209571bf92daf9aa41f497dcee626705ef2ff320d76a4a8a1fec4b1d0b83897f4dede5990e4bcb9ba9fb30e5eb39a0400e627ec3fd33e05bd46b84f1d88fb71389010f03f1783d2639b1acd94c87c18f8df592c92d78ff45a0709fb6d2eb71c2e76187cf62c2fd7fb0a8103870abdcdd0d98702f92ec7dd31d3133b16af5a1f2dd2e7f2105b80ed7a26cf4a2b263bcdf1887a2edd8bbb09a66ef870c39f9317e65942fd8f11487220b2d11cdd11855303b16c6f5fc5ebedc8e2f44d95def8a728f1fabeffbac71bba527d00de98d6c6859c2ad565dd7958664334d92da32ff6bac5f15d9a22adb161c320397a294fd99999f05d53399f38a248ba6017b4a421c1fc6b347df4fc86ef641b69834a5ca9d21b90d005f047ea4e8a641b975cdb2c701b22efff5068b6cb710f1108896d70b82d8fd670dad84dcaad908d074601781c0574e10e9e1848ba595ea5c7806eac63e819f87406964a74612226ac36d77f42833a5061e959165d613638c1aeb368104904a7093147105da91bee3a1880d53708ed0cffe5823ede45daa9d9809dd9b0a751351a4cd8e69afa711ba40ad3e64c7f5606b3923e445c24b023d3021e891438986f2e1b6ace818c10adc592cba7a479b4df2ad4abbb7ed6e87abc2623e9a534615d0846161586c7d76472760692745dce26d7dc123a94934d7532873ae9e3152e67779a7ab03786a1c2ce38f6fe09afd049d45b5b7ad97fad40182b90c0d097813371a4c6033380687099736065ae38d8472ff8c43226a5f6dd3e4c32244bc13191c3cebdda6d74104f93617acfa665e6a2742fa6a3d5f3cc810857d9fe7df36f11a7723dc8cdf3a160da2037225c2a62c29677c054f43091fbdf4cb8eddb8a0cf64b17065c29316031f59e2af9fb0616d3c69237315c8775a35cb7050a10814d43993aa44d2bdcc110744794cfd7abf971201272eb7d8085ac6c01f219ae52fe31ff83157417e7b487acd6f52cb883e3697b71794339085544439b2898fb8766c5cf493668d62a7f3c12358330fb06faea3b783e7e72acd028f40566e96ce86f66dfad7ce988ee3b536a144156ba029e267e6f34fe0ce85729f18e7032b1865611dc198645ae33efa2b08374768e44e20ed68c9625df4f585c48e159a5875e1c7ec9b79dbe6d9023599eadb8e23b7dca523b544232349987e0266d05f2895c31ccd867c84d48918242723119039acd96aa32f21b7b812b78bd8f6ea6bab10816357d6f9ecefc4ea026e68b78f8731bb21bda2c6fb7e7471b22edcf2b3154b9579766dd398250b47baf803a64648733ee362c6ec7f3beff02f0d3e80226077430686c13f906a840d5c34ccd612ffc5d91b66aa814c6b85230133242f12690667ab0a6aac4dbfb4b0db60b22425e24af6a90806c14c74ea36f9e1aecc30f789ea6c3d0abb97fb5f9addbf64216100cee448304faac9b9adf1c5fb45944d10a7408a294da648f4761ad4fc504b6fd8534b0af6bdcddb657e6107021c61b8932906cae9b9744e423c76824d06108e72109f267ae20a2efb60cf601bad6a30c43f496707ae704f30a91a92bf238bbd94ecef9fa159b7e9352b70fab9695ca02830f28aaf2d86a21f154d517c80e7e3929aaf1e10819347181f0480b0e8a873a8fc2702b0e33e424a420479989c59c5e4be57210f718054c11f7e5b10f62c7553d87e440d0ee64c51ee4f2f2afa400c79b5b5a48f7b6ba85f0fe2e3b62c0f2c066c5fef61c238dd821e662b64cc217c4b53d7820221c3f0cefbbac7fd1154191fe645b95bd202a057fd2031582ba16e6df303acb3f5081276658a515563f696fa9a6d0592f76cbb1dbf58ca8783ac59da3355d9742475f7eda3fc3f48e788fe5b8096c14b203a93409517d5442ed4e64a5115d1d596d3d92890c556e94101db4d1d7ada3d3099f17a88d1ebd6ee669ba176cba2dab2f323b1114a9ff0991215741ef3f06029292d0504e040d9d0ad155b1a1049dbe28bc34bc3355b09f0367fc5278f27abab622618b4d39f57f3c40545142089ac73d8b1e4c5c55d999d13b9d66e45deb1d7dc036c0a71e9696da9b212b24c6ffca4735259ef96c0f662a402d602469b57b2f227e1be9674978b4cae33f3b1a6f4afb0085383376f7dd73d257457df3f9150d9c3a6236272e8c74866958c84307e46f5da64fd3ea870d4cb4c9f424a09133f67bde1775fc9c9f100fb47b123c2543499c0db621bb5fbd3fb1ce09b89eaf0e561b3da2f3444880e3ea11646c30e977a824e99b278e80d561065d208e224754abb5bb3df62f6ca400b99d57218fd9bbcfddcc63b220b1d3af956a34f5af8213268893b5c83c9a5b495caad70238de5523e870b5a87313ebda9afcda31d95d2d73fc7365662f398af269b20b7a1eb2fae19dd2e4357b2d9ddfcef021b91a1d311a9a8ec445b8a68d786569e2f74ef35b03722bba8b1b20d6b590ead100abb60a8bbef4f545d18b04692d9a892052d4bb1566a6042da1ac0740d62d7d21a2472cee3b07e4c6dd67819a87fbe7bdc7d9fb0c87fcaeddff639be67a593ff65f0ac7392405a13117894a2fd67c076abfbe3fccd07a96d07097a93b9b36d1f084c6c730569f5bbff9c5b9646c429c0bcd2057f820327a5abb09363441bb174e433fd9fde0af4bcbdde0a41ccbd2733100c0f73b88f22785674188c2abbf2fc83a07babf77945165dee54893663b6baa47a3e482fd2f1ec91183248b79d0033050c3a156598ef116b790a03861b8e4ed1428041fe5daca9079e5ea9f95e617b21e4cabb1d9ccc6fa3440c4b622fd6c016c22ff936fe060f1f8cd8dcc0f42d806d774299f320b7b2e4c979c691816d1e0cf5ef1bb80bc35c0f875805cad3d0c860daeebddecdb35df7149cb5bf4209a72bf13791ae67f67bae8ee2749bbf80523292f65a5d0c55c0cd7947fecd5a223658e75e6bdf6a57cce1c8257393ecd15f188e884a67cfb1a59f803f4230cf85ee63208077fd667582ab263d3c54521826d572053735f1d7639435695a17b498eb2506dab47c7524d0cd5490f0a5a4535a3d428a8ec98e4c81a723c6db4582c7fbc81d9c308a657e894b56ff362b4a357977b4851349a61fdf05c3ee92add50bd70b5a96b812f5ce86c772ba01dcca28bb8df0a84124a0580f67ea0f5dce9e91c92f5463b5ecd659ac375cea4698916ba723d594b54c067f6c2ca9d800a9f53a8e8aae1fb1c2ec9f283d445d3deec1b153b5783bbe8b03b4aec4f44e80974731d405b3ed5cb63204277eee6d36002d92b76b14c76477978c402de518ad3a1f028f251210cf5c3c711ce810b4cab7e2589298f0d0490def4ec49b911b80d2924a8ed21e386d3454abda4e5a49e4e59e3e14f4887dede593ff607278fc82f40b953a54bb4cd7a83f64c4a12050487b70bb882ae84d27f1e78055fc97b858c8215fe90fb702fe1ae159111fd2a57b36e42d7c0fc978794f46cc0f5c64bb429b709df9dd4e651bddd4d74fad76a39e9966f743338016752a0a97cccb3bc569a1011425eb4b0069a3b82876e2e739d1c88ea61fd1d976e9be92132244d395394653e294c2a5fd76a211c0ba3422740df44bf186bc46d1a4468bbbbef6b3039c1e8c13f754dcccc2aff9680e7a0aae09e4fa0693cbeed5f6575309a70c771ae04bbb5d4f0e28434854fb36ab04afe29442ac802c200f90c80df4af87f6a49ed9c7f51313dbc6d00d6959d7fd3f2ce161a770d07ffd9dd4af731b1c4e8f78419883a61c7ca72920450f6303280e8c40d234609eb6fd68f0a9c570c80eeabe1e397b0fd88fdcddc40f45b8e720903db3ba765d0bfb9e9a855555fb8e6e9665569df8320fa0768ff73f5ecf73b6ff479cab8c795a8549f47d5ecb63f163ec3e515ec2ed2d41a8c11f2df33e0f1050d56404bea2641976efbefa7a0a27fd0c1f0ddec2069d5d4d35161dbbc2649f0f7ee7eb815d42536bb354e30fb33edc5af4c75a3f1c890b3c239b247b08077ba96df8d9c0bac16cbbe02da12badd2c3d6303bbdaeffbbefa41eef7871234749c08a86fdcbaae7aab045cea98831a3b2cd2b707ddcf444595f7ea7dac821c0a4f818adc8ab26c84504e821cb26968a34f318d52d0adc5e3863fed9d14a1e9f08aeb1a95bd274e53c69afb9d15240ac9f361a9257a02d08da4ba3263eaaa8b4c771cfc40e8ec1161da0ee4eac20e25dcf8e3e66e15fe09b6db776640ed83993e9b4ed05665bb98d337a8ba95525a604c46301c16ad5044c35bfc0a7e0c8856fd3ca19de448fb16f213aab825e03353595c81365badcc803af177ca013c2c6d562508634de92ef1dbd4798d79e3cbb6e8edccb3132feed8415ada01086d5b21ca07099f7f1882681e79913d9afb177ec02d16d1e1c471d2252f845ca8658e68a8f7fdf1f43aa31a937b2c85ab58899e0beb055fe5a8e0bee78592af63b8f0066045531c9c1a1a7e49e57564df]]></content>
      <categories>
        <category>有感</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
