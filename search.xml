<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F31%2Fexport%2Fexport%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[RegRxp(正则表达式) 简化对字符串的操作正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等 什么是正则？规则、模式; 强大的字符串匹配的工具 风格js风格: const reg = new RegExp(‘a’, i)perl风格: const reg = /a/i 转义字符 | 转义字符 | 说明 || ———- | — || \d | 数字 [0-9]||\|斜杠 ||\n|换行 ||\w|英文 数字 下划线 [a-z0-9_]||\s|空格||\D|除了数字 [^0-9]||\W|非数字 字母 下划线 [^z-a0-9_]||\S|非空白字符| 特殊字符(元字符) [] 方括号 12345// [abc] 表示a或者b或者c const re = /[abc]pc/g// 范围匹配[a-z] [0-9] [^a-z] // 匹配非英文部分 限定符(量词) 基本形式： {n}表示出现的次数 12// 8位电话号码 /[1-9]\d&#123;7&#125;/ // 以非零数字开头后面八位随意 表示出现次数范围： {n, m} 表示出现最少n次 最多m次 12345678910// QQ 正则/[1-9]\d&#123;4, 10&#125;/``` - 不限次数：&#123;n, &#125; 表示最少n次， 最多不限 . 任意字符*: =&gt; &#123;0, &#125; 任意次+: 若干 =&gt; &#123;1, &#125; 最少一次 最多不限 ?: 最少零次 最多一次 =&gt; &#123;0, 1&#125; ^: 行首 $: 行尾 固话区号 010-2473544(0\d{2,3}-)?[1-9]\d{7} 1234567891011121314- 方法 - search 返回匹配的位置 - match 把所有匹配的东西都提取出来 - replace 字符串替换,替换所有匹配的字符串，返回替换以后的字符串 - test 检验字符串是否符合正则 返回Boolean &gt; 特性 只要字符串一部分符合要求就返回true ```js // 校验邮箱 const email = &apos;你好啊heiliu@Gmail.com&apos; const re = /\w+@[a-z0-9]+\.[a-z]+/ re.test(email) // 后半部分符合 返回 true const re1 = /^\w+@[a-z0-9]+\.[a-z]+$/ // 限制首尾 应用例子 查找字符串中的数字并返回 1234567891011 // 查找字符串中的数字 const str = '123ask32lks,alf21lksa12e45l3' const reg = /\d+/g // global console.log(str.match(reg))``` - 敏感词过滤 ```js // replace 的用例 const reg = /匹配|出来/; const str = '把所有匹配的东西都提取出来 ' console.log(str.replace(reg, '***')) // 把所有***的东西都提取***]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F31%2Fexport%2Fexport%2Findex%2F</url>
    <content type="text"><![CDATA[title var link = document.createElement('link'); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = window.location.search.match(/print-pdf/gi) ? 'libs/reveal.js/3.7.0/css/print/pdf.css' : 'libs/reveal.js/3.7.0/css/print/paper.css'; document.getElementsByTagName('head')[0].appendChild(link); /* Solarized Light theme */ .line { display: block; } .line.focus { background: #fdf6e3; color: #657b83; } .line.focus .hljs-comment, .line.focus .hljs-quote { color: #93a1a1; } .line.focus .hljs-keyword, .line.focus .hljs-selector-tag, .line.focus .hljs-addition { color: #859900; } .line.focus .hljs-number, .line.focus .hljs-string, .line.focus .hljs-meta .hljs-meta-string, .line.focus .hljs-literal, .line.focus .hljs-doctag, .line.focus .hljs-regexp { color: #2aa198; } .line.focus .hljs-title, .line.focus .hljs-section, .line.focus .hljs-name, .line.focus .hljs-selector-id, .line.focus .hljs-selector-class { color: #268bd2; } .line.focus .hljs-attribute, .line.focus .hljs-attr, .line.focus .hljs-variable, .line.focus .hljs-template-variable, .line.focus .hljs-class .hljs-title, .line.focus .hljs-type { color: #b58900; } .line.focus .hljs-symbol, .line.focus .hljs-bullet, .line.focus .hljs-subst, .line.focus .hljs-meta, .line.focus .hljs-meta .hljs-keyword, .line.focus .hljs-selector-attr, .line.focus .hljs-selector-pseudo, .line.focus .hljs-link { color: #cb4b16; } .line.focus .hljs-built_in, .line.focus .hljs-deletion { color: #dc322f; } .line.focus .hljs-formula { background: #eee8d5; } .line.focus .hljs-emphasis { font-style: italic; } .line.focus .hljs-strong { font-weight: bold; } .yellow-slide .line.focus:nth-child(2) { background: yellow; } .reveal .slides section .code-presenting-annotation { font-size: 70%; } .reveal .slides section .fragment.current-only { visibility: visible; display: none; } .reveal .slides section .fragment.current-only.current-fragment { display: block; } .line { display: block; } .line.focus { /* opacity: 1.0; */ } .hljs { background: none; } .reveal pre { width: 98%; margin: 0px; box-shadow: none; } .reveal pre code { font-size: 1.2em; line-height: 1.2; border-radius: 10px; max-height: 60vh !important; overflow: hidden !important; } @media (device-width: 100vw) and (device-height: 100vh) { .reveal pre code { max-height: 50vh !important; } } #logo img { max-height: 3.5em; max-width: none; min-width: 50px; } .reveal .slides section .code-presenting-annotation { color: white; background: black; padding: 0px 15px; border-radius: 15px; opacity: 0.75 !important; font-size: 50% !important; } if(window.location.search.match( /print-pdf-now/gi )) { window.print(); } // More info https://github.com/hakimel/reveal.js#configuration Reveal.initialize({ controls: true, controlsTutorial: true, controlsLayout: 'bottom-right', controlsBackArrows: 'faded', progress: true, slideNumber: false, history: true, keyboard: true, overview: true, center: true, touch: true, loop: false, rtl: false, shuffle: false, fragments: true, fragmentInURL: false, embedded: false, help: true, showNotes: false, autoPlayMedia: false, autoSlide: 0, autoSlideStoppable: true, autoSlideMethod: Reveal.navigateNext, defaultTiming: 120, mouseWheel: false, hideAddressBar: true, previewLinks: false, transition: 'default', transitionSpeed: 'default', backgroundTransition: 'default', viewDistance: 3, parallaxBackgroundImage: '', parallaxBackgroundSize: '', parallaxBackgroundHorizontal: null, parallaxBackgroundVertical: null, display: 'block', // More info https://github.com/hakimel/reveal.js#dependencies dependencies: [ // { src: 'libs/reveal.js/3.7.0/lib/js/classList.js', condition: function () { return !document.body.classList; } }, { src: 'libs/reveal.js/3.7.0/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } }, { src: 'libs/reveal.js/3.7.0/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } }, // { src: 'libs/reveal.js/3.7.0/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }, { src: 'libs/reveal.js/3.7.0/plugin/search/search.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/zoom-js/zoom.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/notes/notes.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/chalkboard/chalkboard.js' }, { src: 'libs/reveal.js/3.7.0/plugin/chart/Chart.min.js' }, { src: 'libs/reveal.js/3.7.0/plugin/chart/csv2chart.js' }, { src: 'libs/reveal.js/3.7.0/plugin/embed-tweet/embed-tweet.js' }, { src: 'libs/reveal.js/3.7.0/plugin/menu/menu.js' }, { src: 'libs/reveal.js/3.7.0/plugin/math/math.js', async: true }, { src: 'libs/highlight.js/9.12.0/highlight.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }, { src: 'libs/highlight.js/9.12.0/reveal-code-focus-1.0.0-mod.js', async: true, callback: function() { RevealCodeFocus(); } }, // { src: 'libs/reveal.js/3.7.0/plugin/reveal-code-focus/highlight.pack.js' }, // { src: 'libs/reveal.js/3.7.0/plugin/reveal-code-focus/reveal-code-focus.js', async: true, callback: function() { RevealCodeFocus(); } }, // {src: 'libs/reveal.js/3.7.0/plugin/line-numbers/line-numbers.js'} ] , keyboard: { 67: function () { RevealChalkboard.toggleNotesCanvas() }, // toggle notes canvas when 'c' is pressed 66: function () { RevealChalkboard.toggleChalkboard() }, // toggle chalkboard when 'b' is pressed 46: function () { RevealChalkboard.clear() }, // clear chalkboard when 'DEL' is pressed 8: function () { RevealChalkboard.reset() }, // reset chalkboard data on current slide when 'BACKSPACE' is pressed 68: function () { RevealChalkboard.download() }, // downlad recorded chalkboard drawing when 'd' is pressed }, math: { mathjax: 'libs/reveal.js/3.7.0/plugin/math/MathJax.js', // mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js', config: 'TeX-AMS_HTML-full' }, chart: { defaults: { global: { title: { fontColor: "#FFF" }, legend: { position: "bottom", labels: { fontColor: "#FFF" }, }, tooltips: { labels: { fontColor: "#FFF" }, }, }, scale: { scaleLabel: { fontColor: "#FFF" }, gridLines: { color: "#FFF", zeroLineColor: "#FFF" }, ticks: { fontColor: "#FFF" }, } }, line: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ], "borderDash": [ [5,10], [0,0] ] }, bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]}, pie: { backgroundColor: [ ["rgba(0,0,0,.8)" , "rgba(220,20,20,.8)", "rgba(20,220,20,.8)", "rgba(220,220,20,.8)", "rgba(20,20,220,.8)"] ]}, radar: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]}, }, menu: { // Specifies which side of the presentation the menu will // be shown. Use 'left' or 'right'. side: 'left', // Specifies the width of the menu. // Can be one of the following: // 'normal', 'wide', 'third', 'half', 'full', or // any valid css length value width: 'normal', // Add slide numbers to the titles in the slide list. // Use 'true' or format string (same as reveal.js slide numbers) numbers: false, // Specifies which slide elements will be used for generating // the slide titles in the menu. The default selects the first // heading element found in the slide, but you can specify any // valid css selector and the text from the first matching // element will be used. // Note: that a section data-menu-title attribute or an element // with a menu-title class will take precedence over this option titleSelector: 'h1, h2, h3, h4, h5, h6', // If slides do not have a matching title, attempt to use the // start of the text content as the title instead useTextContentForMissingTitles: false, // Hide slides from the menu that do not have a title. // Set to 'true' to only list slides with titles. hideMissingTitles: false, // Adds markers to the slide titles to indicate the // progress through the presentation. Set to 'false' // to hide the markers. markers: true, // Specify custom panels to be included in the menu, by // providing an array of objects with 'title', 'icon' // properties, and either a 'src' or 'content' property. // custom: false, custom: [ ], // Specifies the themes that will be available in the themes // menu panel. Set to 'true' to show the themes menu panel // with the default themes list. Alternatively, provide an // array to specify the themes to make available in the // themes menu panel, for example... // [ // { name: 'Black', theme: 'css/theme/black.css' }, // { name: 'White', theme: 'css/theme/white.css' }, // { name: 'League', theme: 'css/theme/league.css' } // ] themes: false, // Specifies the path to the default theme files. If your // presentation uses a different path to the standard reveal // layout then you need to provide this option, but only // when 'themes' is set to 'true'. If you provide your own // list of themes or 'themes' is set to 'false' the // 'themesPath' option is ignored. themesPath: 'css/theme/', // Specifies if the transitions menu panel will be shown. // Set to 'true' to show the transitions menu panel with // the default transitions list. Alternatively, provide an // array to specify the transitions to make available in // the transitions panel, for example... // ['None', 'Fade', 'Slide'] transitions: false, // Adds a menu button to the slides to open the menu panel. // Set to 'false' to hide the button. openButton: true, // If 'true' allows the slide number in the presentation to // open the menu panel. The reveal.js slideNumber option must // be displayed for this to take effect openSlideNumber: false, // If true allows the user to open and navigate the menu using // the keyboard. Standard keyboard interaction with reveal // will be disabled while the menu is open. keyboard: true, // Normally the menu will close on user actions such as // selecting a menu item, or clicking the presentation area. // If 'true', the sticky option will leave the menu open // until it is explicitly closed, that is, using the close // button or pressing the ESC or m key (when the keyboard // interaction option is enabled). sticky: false, // If 'true' standard menu items will be automatically opened // when navigating using the keyboard. Note: this only takes // effect when both the 'keyboard' and 'sticky' options are enabled. autoOpen: true, // If 'true' the menu will not be created until it is explicitly // requested by calling RevealMenu.init(). Note this will delay // the creation of all menu panels, including custom panels, and // the menu button. delayInit: false, // If 'true' the menu will be shown when the menu is initialised. openOnInit: false, // By default the menu will load it's own font-awesome library // icons. If your presentation needs to load a different // font-awesome library the 'loadIcons' option can be set to false // and the menu will not attempt to load the font-awesome library. loadIcons: false }, chalkboard: { toggleChalkboardButton: { left: "60px", bottom: "30px", top: "auto", right: "auto" }, toggleNotesButton: { left: "90px", bottom: "30px", top: "auto", right: "auto" }, } });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F31%2Fexport%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[RegRxp(正则表达式) 简化对字符串的操作正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等 什么是正则？规则、模式; 强大的字符串匹配的工具 风格js风格: const reg = new RegExp(‘a’, i)perl风格: const reg = /a/i 转义字符 | 转义字符 | 说明 || ———- | — || \d | 数字 [0-9]||\|斜杠 ||\n|换行 ||\w|英文 数字 下划线 [a-z0-9_]||\s|空格||\D|除了数字 [^0-9]||\W|非数字 字母 下划线 [^z-a0-9_]||\S|非空白字符| 特殊字符(元字符) [] 方括号 12345// [abc] 表示a或者b或者c const re = /[abc]pc/g// 范围匹配[a-z] [0-9] [^a-z] // 匹配非英文部分 限定符(量词) 基本形式： {n}表示出现的次数 12// 8位电话号码 /[1-9]\d&#123;7&#125;/ // 以非零数字开头后面八位随意 表示出现次数范围： {n, m} 表示出现最少n次 最多m次 12345678910// QQ 正则/[1-9]\d&#123;4, 10&#125;/``` - 不限次数：&#123;n, &#125; 表示最少n次， 最多不限 . 任意字符*: =&gt; &#123;0, &#125; 任意次+: 若干 =&gt; &#123;1, &#125; 最少一次 最多不限 ?: 最少零次 最多一次 =&gt; &#123;0, 1&#125; ^: 行首 $: 行尾 固话区号 010-2473544(0\d{2,3}-)?[1-9]\d{7} 1234567891011121314- 方法 - search 返回匹配的位置 - match 把所有匹配的东西都提取出来 - replace 字符串替换,替换所有匹配的字符串，返回替换以后的字符串 - test 检验字符串是否符合正则 返回Boolean &gt; 特性 只要字符串一部分符合要求就返回true ```js // 校验邮箱 const email = &apos;你好啊heiliu@Gmail.com&apos; const re = /\w+@[a-z0-9]+\.[a-z]+/ re.test(email) // 后半部分符合 返回 true const re1 = /^\w+@[a-z0-9]+\.[a-z]+$/ // 限制首尾 应用例子 查找字符串中的数字并返回 1234567891011 // 查找字符串中的数字 const str = '123ask32lks,alf21lksa12e45l3' const reg = /\d+/g // global console.log(str.match(reg))``` - 敏感词过滤 ```js // replace 的用例 const reg = /匹配|出来/; const str = '把所有匹配的东西都提取出来 ' console.log(str.replace(reg, '***')) // 把所有***的东西都提取***]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F31%2Fexport%2Findex%2F</url>
    <content type="text"><![CDATA[RegExp(正则表达式) var link = document.createElement('link'); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = window.location.search.match(/print-pdf/gi) ? 'libs/reveal.js/3.7.0/css/print/pdf.css' : 'libs/reveal.js/3.7.0/css/print/paper.css'; document.getElementsByTagName('head')[0].appendChild(link); /* Solarized Light theme */ .line { display: block; } .line.focus { background: #fdf6e3; color: #657b83; } .line.focus .hljs-comment, .line.focus .hljs-quote { color: #93a1a1; } .line.focus .hljs-keyword, .line.focus .hljs-selector-tag, .line.focus .hljs-addition { color: #859900; } .line.focus .hljs-number, .line.focus .hljs-string, .line.focus .hljs-meta .hljs-meta-string, .line.focus .hljs-literal, .line.focus .hljs-doctag, .line.focus .hljs-regexp { color: #2aa198; } .line.focus .hljs-title, .line.focus .hljs-section, .line.focus .hljs-name, .line.focus .hljs-selector-id, .line.focus .hljs-selector-class { color: #268bd2; } .line.focus .hljs-attribute, .line.focus .hljs-attr, .line.focus .hljs-variable, .line.focus .hljs-template-variable, .line.focus .hljs-class .hljs-title, .line.focus .hljs-type { color: #b58900; } .line.focus .hljs-symbol, .line.focus .hljs-bullet, .line.focus .hljs-subst, .line.focus .hljs-meta, .line.focus .hljs-meta .hljs-keyword, .line.focus .hljs-selector-attr, .line.focus .hljs-selector-pseudo, .line.focus .hljs-link { color: #cb4b16; } .line.focus .hljs-built_in, .line.focus .hljs-deletion { color: #dc322f; } .line.focus .hljs-formula { background: #eee8d5; } .line.focus .hljs-emphasis { font-style: italic; } .line.focus .hljs-strong { font-weight: bold; } .yellow-slide .line.focus:nth-child(2) { background: yellow; } .reveal .slides section .code-presenting-annotation { font-size: 70%; } .reveal .slides section .fragment.current-only { visibility: visible; display: none; } .reveal .slides section .fragment.current-only.current-fragment { display: block; } .line { display: block; } .line.focus { /* opacity: 1.0; */ } .hljs { background: none; } .reveal pre { width: 98%; margin: 0px; box-shadow: none; } .reveal pre code { font-size: 1.2em; line-height: 1.2; border-radius: 10px; max-height: 60vh !important; overflow: hidden !important; } @media (device-width: 100vw) and (device-height: 100vh) { .reveal pre code { max-height: 50vh !important; } } #logo img { max-height: 3.5em; max-width: none; min-width: 50px; } .reveal .slides section .code-presenting-annotation { color: white; background: black; padding: 0px 15px; border-radius: 15px; opacity: 0.75 !important; font-size: 50% !important; } if(window.location.search.match( /print-pdf-now/gi )) { window.print(); } // More info https://github.com/hakimel/reveal.js#configuration Reveal.initialize({ controls: true, controlsTutorial: true, controlsLayout: 'bottom-right', controlsBackArrows: 'faded', progress: true, slideNumber: false, history: true, keyboard: true, overview: true, center: true, touch: true, loop: false, rtl: false, shuffle: false, fragments: true, fragmentInURL: false, embedded: false, help: true, showNotes: false, autoPlayMedia: false, autoSlide: 0, autoSlideStoppable: true, autoSlideMethod: Reveal.navigateNext, defaultTiming: 120, mouseWheel: false, hideAddressBar: true, previewLinks: false, transition: 'default', transitionSpeed: 'default', backgroundTransition: 'default', viewDistance: 3, parallaxBackgroundImage: '', parallaxBackgroundSize: '', parallaxBackgroundHorizontal: null, parallaxBackgroundVertical: null, display: 'block', // More info https://github.com/hakimel/reveal.js#dependencies dependencies: [ // { src: 'libs/reveal.js/3.7.0/lib/js/classList.js', condition: function () { return !document.body.classList; } }, { src: 'libs/reveal.js/3.7.0/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } }, { src: 'libs/reveal.js/3.7.0/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } }, // { src: 'libs/reveal.js/3.7.0/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }, { src: 'libs/reveal.js/3.7.0/plugin/search/search.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/zoom-js/zoom.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/notes/notes.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/chalkboard/chalkboard.js' }, { src: 'libs/reveal.js/3.7.0/plugin/chart/Chart.min.js' }, { src: 'libs/reveal.js/3.7.0/plugin/chart/csv2chart.js' }, { src: 'libs/reveal.js/3.7.0/plugin/embed-tweet/embed-tweet.js' }, { src: 'libs/reveal.js/3.7.0/plugin/menu/menu.js' }, { src: 'libs/reveal.js/3.7.0/plugin/math/math.js', async: true }, { src: 'libs/highlight.js/9.12.0/highlight.js', async: true }, { src: 'libs/reveal.js/3.7.0/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }, { src: 'libs/highlight.js/9.12.0/reveal-code-focus-1.0.0-mod.js', async: true, callback: function() { RevealCodeFocus(); } }, // { src: 'libs/reveal.js/3.7.0/plugin/reveal-code-focus/highlight.pack.js' }, // { src: 'libs/reveal.js/3.7.0/plugin/reveal-code-focus/reveal-code-focus.js', async: true, callback: function() { RevealCodeFocus(); } }, // {src: 'libs/reveal.js/3.7.0/plugin/line-numbers/line-numbers.js'} ] , keyboard: { 67: function () { RevealChalkboard.toggleNotesCanvas() }, // toggle notes canvas when 'c' is pressed 66: function () { RevealChalkboard.toggleChalkboard() }, // toggle chalkboard when 'b' is pressed 46: function () { RevealChalkboard.clear() }, // clear chalkboard when 'DEL' is pressed 8: function () { RevealChalkboard.reset() }, // reset chalkboard data on current slide when 'BACKSPACE' is pressed 68: function () { RevealChalkboard.download() }, // downlad recorded chalkboard drawing when 'd' is pressed }, math: { mathjax: 'libs/reveal.js/3.7.0/plugin/math/MathJax.js', // mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js', config: 'TeX-AMS_HTML-full' }, chart: { defaults: { global: { title: { fontColor: "#FFF" }, legend: { position: "bottom", labels: { fontColor: "#FFF" }, }, tooltips: { labels: { fontColor: "#FFF" }, }, }, scale: { scaleLabel: { fontColor: "#FFF" }, gridLines: { color: "#FFF", zeroLineColor: "#FFF" }, ticks: { fontColor: "#FFF" }, } }, line: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ], "borderDash": [ [5,10], [0,0] ] }, bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]}, pie: { backgroundColor: [ ["rgba(0,0,0,.8)" , "rgba(220,20,20,.8)", "rgba(20,220,20,.8)", "rgba(220,220,20,.8)", "rgba(20,20,220,.8)"] ]}, radar: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]}, }, menu: { // Specifies which side of the presentation the menu will // be shown. Use 'left' or 'right'. side: 'left', // Specifies the width of the menu. // Can be one of the following: // 'normal', 'wide', 'third', 'half', 'full', or // any valid css length value width: 'normal', // Add slide numbers to the titles in the slide list. // Use 'true' or format string (same as reveal.js slide numbers) numbers: false, // Specifies which slide elements will be used for generating // the slide titles in the menu. The default selects the first // heading element found in the slide, but you can specify any // valid css selector and the text from the first matching // element will be used. // Note: that a section data-menu-title attribute or an element // with a menu-title class will take precedence over this option titleSelector: 'h1, h2, h3, h4, h5, h6', // If slides do not have a matching title, attempt to use the // start of the text content as the title instead useTextContentForMissingTitles: false, // Hide slides from the menu that do not have a title. // Set to 'true' to only list slides with titles. hideMissingTitles: false, // Adds markers to the slide titles to indicate the // progress through the presentation. Set to 'false' // to hide the markers. markers: true, // Specify custom panels to be included in the menu, by // providing an array of objects with 'title', 'icon' // properties, and either a 'src' or 'content' property. // custom: false, custom: [ ], // Specifies the themes that will be available in the themes // menu panel. Set to 'true' to show the themes menu panel // with the default themes list. Alternatively, provide an // array to specify the themes to make available in the // themes menu panel, for example... // [ // { name: 'Black', theme: 'css/theme/black.css' }, // { name: 'White', theme: 'css/theme/white.css' }, // { name: 'League', theme: 'css/theme/league.css' } // ] themes: false, // Specifies the path to the default theme files. If your // presentation uses a different path to the standard reveal // layout then you need to provide this option, but only // when 'themes' is set to 'true'. If you provide your own // list of themes or 'themes' is set to 'false' the // 'themesPath' option is ignored. themesPath: 'css/theme/', // Specifies if the transitions menu panel will be shown. // Set to 'true' to show the transitions menu panel with // the default transitions list. Alternatively, provide an // array to specify the transitions to make available in // the transitions panel, for example... // ['None', 'Fade', 'Slide'] transitions: false, // Adds a menu button to the slides to open the menu panel. // Set to 'false' to hide the button. openButton: true, // If 'true' allows the slide number in the presentation to // open the menu panel. The reveal.js slideNumber option must // be displayed for this to take effect openSlideNumber: false, // If true allows the user to open and navigate the menu using // the keyboard. Standard keyboard interaction with reveal // will be disabled while the menu is open. keyboard: true, // Normally the menu will close on user actions such as // selecting a menu item, or clicking the presentation area. // If 'true', the sticky option will leave the menu open // until it is explicitly closed, that is, using the close // button or pressing the ESC or m key (when the keyboard // interaction option is enabled). sticky: false, // If 'true' standard menu items will be automatically opened // when navigating using the keyboard. Note: this only takes // effect when both the 'keyboard' and 'sticky' options are enabled. autoOpen: true, // If 'true' the menu will not be created until it is explicitly // requested by calling RevealMenu.init(). Note this will delay // the creation of all menu panels, including custom panels, and // the menu button. delayInit: false, // If 'true' the menu will be shown when the menu is initialised. openOnInit: false, // By default the menu will load it's own font-awesome library // icons. If your presentation needs to load a different // font-awesome library the 'loadIcons' option can be set to false // and the menu will not attempt to load the font-awesome library. loadIcons: false }, chalkboard: { toggleChalkboardButton: { left: "60px", bottom: "30px", top: "auto", right: "auto" }, toggleNotesButton: { left: "90px", bottom: "30px", top: "auto", right: "auto" }, } });]]></content>
  </entry>
  <entry>
    <title><![CDATA[同一台电脑配置多个SSH]]></title>
    <url>%2F2019%2F07%2F31%2FmultiSSH%2F</url>
    <content type="text"><![CDATA[配置多个SSH在工作中多访问公司的gitlab仓库，而在生活中又有自己的gayhub仓库记录一下方便日后查找 一般电脑中的SSH key 存放在 ～/.ssh目录中 如果有配置过的话存在 id_rsa \ id_rsa.pub 私钥和公钥, 将公钥配置到需要的代码平台 生成SSH key 本地配置多个ssh key 1、为公司生成一对秘钥ssh key 1ssh-keygen -t rsa -C 'yourEmail@xx.com' -f ~/.ssh/gitlab_id_rsa 2、为github生成一对秘钥ssh key 123456789101112131415161718 ssh-keygen -t rsa -C 'yourEmail2@xx.com' -f ~/.ssh/github_id_rsa``` - 3、在~/.ssh目录下新建名称为`config`的文件（无后缀名）。 用于配置多个不同的host使用不同的ssh key，常用内容如下：```js # gitlab Host gitlab.planetmeican.com HostName gitlab.planetmeican.com Port 2345 User git PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa``` 配置文件参数Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件port: 端口号，一般不需要配置HostName : 要登录主机的主机名#PreferredAuthentications: 授权验证方式 User : 登录名IdentityFile : 指明上面User对应的identityFile路径` 4、分别往gitlab和github上添加生成的公钥]]></content>
      <categories>
        <category>倒腾</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[serverless了解]]></title>
    <url>%2F2019%2F07%2F29%2Fserverless%2F</url>
    <content type="text"><![CDATA[serverless了解]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux中Provider、connect]]></title>
    <url>%2F2019%2F07%2F29%2Fprovider%26%26connect%2F</url>
    <content type="text"><![CDATA[react-redux中Provider详情]]></content>
      <categories>
        <category>React</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 参数]]></title>
    <url>%2F2019%2F07%2F29%2FnpmParams%2F</url>
    <content type="text"><![CDATA[npm 参数npm install -g webpacknpm install prop-types –save-dev]]></content>
      <categories>
        <category>Skill</category>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 笔记]]></title>
    <url>%2F2019%2F07%2F28%2FgitNote%2F</url>
    <content type="text"><![CDATA[Git 常用的命令笔记Commitizen是一个撰写合格 Commit message 的工具。 本地分支重命名 git branch -m old new git checkout的用法 git checkout // 不跟参数，则对工作区进行检查 可以返回工作区文件的状态git checkout -b 分支名 // 切换到对应分支 如果没有则新建一条分支git checkout -B 分支名 // 强制切换分支 如果存在同名分支会发生覆盖git checkout commit_id(hash) // 切换到对应的commit版本 （分离头指针） //此时的HEAD不指向分支，指向对应的commit_id 通过 git checkout master 切回分支 checkout命令详解参考 撤回 add/commit 将add到暂存区后的提交撤回git reset head 文件名 修改commit标注commit -m “aaaa” // 提交一个commitgit commit –amend =&gt; 开启vim编辑器 编辑后保存退出 撤回commitgit reset –soft commit_id // 撤回commit 到commit_id soft 只是撤回commit 本地文件不会修改git reset –hard commit_id // 撤回commit 到commit_id hard 只是撤回commit 本地文件回退 添加/删除远程分支 将本地分支推送到远程分支上，如果远程分支不存在，则创建此远程分支 git push origin 本地分支名:远程分支名 $ git push origin test:master // 提交本地test分支作为远程的master分支$ git push origin test:test // 提交本地test分支作为远程的test分支//好像只写这一句，远程的github就会自动创建一个test分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。git push origin :远程分支名(你要删除的远程分支名) git reflog可以显示已删除的操作]]></content>
      <categories>
        <category>Skill</category>
        <category>Note</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基本数据类型和引用类型的区别]]></title>
    <url>%2F2018%2F07%2F30%2Ftype%2F</url>
    <content type="text"><![CDATA[Js 基本数据类型js基本数据类型包括：undefined,null,number,boolean,string.基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值 1.基本数据类型的值是不可改变的 任何方法都无法改变一个基本类型的值是不可改变的，比如一个字符串： 1234567var name = "change";name.substr();//hangconsole.log(name);//changevar s = "hello";s.toUpperCase()//HELLO;console.log(s)//hello 通过这两个例子， 我们原来发现定义的变量name 的值始终没有发生改变，而调用substr() 和 toUpperCase() 方法后返回的是一个新的字符串，跟原先定义的变量name 并没有关系 或许有人会有一下的疑问， 看代码：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化之浏览器篇]]></title>
    <url>%2F2018%2F07%2F20%2FBetter%2F</url>
    <content type="text"><![CDATA[把 Css 放在head 中加载 在浏览器解析完head 部分后、让浏览器知道需要引入哪些css文件，开始并行的去下载css资源，一边下载Css文件一边解析Html, 能够使页面更早的开始渲染 让页面更早的开始渲染、避免闪屏 （DOM 结构先加载出来，css慢了一拍 页面重新渲染） 最好能包含关键渲染路径的样式、首页的样式应该尽快的完成加载、提高用户体验 JS放在 body 标签结束前加载 js 资源的加载会阻塞 HTML 的解析 和 Css的渲染 不使用CSS 表达式 看似强大， 实际性能开销很大，可能导致页面卡顿 用外链的方式引入css 和 js 通过使用外链可以减少html 文件的体积 作为外链文件、Css/Js 可以作为静态资源、通过合理的利用浏览器的缓存对需要的文件进行缓存； 在第二次访问时可以加快页面的加载速度 不要重复加载JS 在IE中，例如在加载一个jquery以后再加载一个jquery，仍然是算作两个不同的请求，不能发挥缓存的优势 重复加载js意味着更长的JS执行时间 用 Get 方式发起 Ajax 请求 Get 方式可以缓存 如果是获取信息 Get 更加语义化 如果是提交数据 使用Post 更加语义化 组件延迟加载 规划页面中引用的姿态资源加载顺序、优先级的能力 保障关键页面资源的优先加载: 浏览器的并发数限制 在同一个域名下面，一般现代浏览器的并发数为6 按需加载 Lazyload 典型： 电商网站 在图片比较多的电商网站中，lazyload 十分实用 data-src -&gt; src 避免在页面中使用iFrame 会阻塞父文档的 onload 事件 即使是空白iFrame 也比较耗时 减少COOKIE体积 COOKIE每次请求都会全都带上COOKIE了解更多 每次请求跟主文档相关的信息，所有的cookie都会带上 减少 JS 中的 DOM 访问 JS中对DOM 的访问是不可避免的, 但可以进行一下优化 对于查找到的元素， 先将其缓存在变量中 节点增加时合理利用 DocumentFragment 不要用JS 去频繁修改样式 使用常见的图片优化手段 相比代码， 图片的体积很大 不要在HTML中缩放图片在实际中使用什么尺寸的图片就提供多大尺寸的图片 徒增渲染开销， 提供适当尺寸即可 不要把图片的src置空 在主流浏览器中 IE、Chrome、FireFox 都会引发指向当前主文档的额外请求]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp 正则表达式]]></title>
    <url>%2F2018%2F07%2F18%2FregExp%2F</url>
    <content type="text"><![CDATA[RegRxp(正则表达式) 简化对字符串的操作 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等 什么是正则？规则、模式; 强大的字符串匹配的工具 风格js风格: const reg = new RegExp(‘a’, i)perl风格: const reg = /a/i 转义字符 | 转义字符 | 说明 || ———- | — || \d | 数字 [0-9]||\|斜杠 ||\n|换行 ||\w|英文 数字 下划线 [a-z0-9_]||\s|空格||\D|除了数字 [^0-9]||\W|非数字 字母 下划线 [^z-a0-9_]||\S|非空白字符| 特殊字符(元字符) [] 方括号 123456// [abc] 表示a或者b或者c const re = /[abc]pc/g// 范围匹配[a-z] [0-9] [^a-z] // 匹配非英文部分 限定符(量词) 基本形式： {n}表示出现的次数 12// 8位电话号码 /[1-9]\d&#123;7&#125;/ // 以非零数字开头后面八位随意 表示出现次数范围： {n, m} 表示出现最少n次 最多m次 12345678910111213141516171819202122232425262728293031 /[1-9]\d&#123;4, 10&#125;/ // QQ 正则 ``` - 不限次数：&#123;n, &#125; 表示最少n次， 最多不限 . 任意字符 *: =&gt; &#123;0, &#125; 任意次 +: 若干 =&gt; &#123;1, &#125; 最少一次 最多不限 ?: 最少零次 最多一次 =&gt; &#123;0, 1&#125; ^: 行首 $: 行尾 ```js (0\d&#123;2,3&#125;-)?[1-9]\d&#123;7&#125; // 固话区号 010-2473544 ``` - 方法 - search 返回匹配的位置 - match 把所有匹配的东西都提取出来 - replace 字符串替换,替换所有匹配的字符串，返回替换以后的字符串 - test 检验字符串是否符合正则 返回Boolean &gt; 特性 只要字符串一部分符合要求就返回true ```js // 校验邮箱 const email = '你好啊heiliu@Gmail.com' const re = /\w+@[a-z0-9]+\.[a-z]+/ re.test(email) // 后半部分符合 返回 true const re1 = /^\w+@[a-z0-9]+\.[a-z]+$/ // 限制首尾 应用例子 查找字符串中的数字并返回 1234567891011 // 查找字符串中的数字 const str = '123ask32lks,alf21lksa12e45l3' const reg = /\d+/g // global console.log(str.match(reg))``` - 敏感词过滤 ```js // replace 的用例 const reg = /匹配|出来/; const str = '把所有匹配的东西都提取出来 ' console.log(str.replace(reg, '***')) // 把所有***的东西都提取***]]></content>
      <categories>
        <category>前端</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件通信]]></title>
    <url>%2F2018%2F07%2F15%2FVueComponentsConnect-md%2F</url>
    <content type="text"><![CDATA[组件 (Component) 是 Vue.js最强大的功能之一。组件可以扩展，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 通信类型父组件与子组件通信 父组件给子组件传递数据 props: 使用props，父组件可以使用props向子组件传递数据 1234567891011121314151617181920// 父组件 &lt;template&gt; &lt;child :msg="message"&gt;&lt;/child&gt;&lt;/template&gt; &lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child &#125;, data () &#123; return &#123; message: 'father message'; &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// 子组件 &lt;template&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; // props 另一种写法, 不声明类型与默认值 // props: ['msg'] props: &#123; msg: &#123; type: String, required: true &#125; &#125; &#125; &lt;/script&gt;``` - 子组件向父组件通信 &gt; 在Vue 中子组件一般不具有操作数据和处理事件的权利，所有的数据和事件的处理都要交给父组件进行操作 **方法一 :** 在子组件中通过$emit()将组件内部的时间传递给父组件的事件进行 ```js // 父组件&lt;template&gt;&lt;child @msgFunc="func"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default &#123;components: &#123; child&#125;,methods: &#123; func (msg) &#123; console.log(msg); &#125;&#125;&#125;&lt;/script&gt;// 子组件 &lt;template&gt;&lt;button @click="handleClick"&gt;点我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;props: &#123; msg: &#123; type: String, required: true &#125;&#125;,methods () &#123; handleClick () &#123; // 提交出去的处理方法的名称与父组件接收的需一致 this.$emit('msgFunc'); &#125;&#125;&#125;&lt;/script&gt; ``` **方法二:** 通过修改父组件传递的props来修改父组件数据 &gt; 这种方法只能在父组件传递一个引用变量时可以使用，字面变量无法达到相应效果。因为饮用变量最终无论是父组件中的数据还是子组件得到的props中的数据都是指向同一块内存地址，所以修改了子组件中props的数据即修改了父组件的数据。&gt; 但是并不推荐这么做，并不建议直接修改props的值，如果数据是用于显示修改的，在实际开发中我经常会将其放入data中，在需要回传给父组件的时候再用事件回传数据。这样做保持了组件独立以及解耦，不会因为使用同一份数据而导致数据流异常混乱，只通过特定的接口传递数据来达到修改数据的目的，而内部数据状态由专门的data负责管理 --- ## 兄弟组件进行通信 &gt; 刚开始学习使用Vue时, 在Vue项目中的两个兄弟组件之间如果要进行通信， 通常会通过一个父组件进行数据请求再给子组件传递数据。 - Vuex 是官方推荐的状态管理方案, 不过如果只是中小型项目，状态管理也没有很复杂的话，使用 Vuex 有种杀鸡用牛刀的感觉 - Vue 官方推荐使用一个 Vue 实例作为中央事件总线, 即 `EventBus` ,在需要使用的地方import该Bus &gt; EventBus 解决了兄弟组件之间的事件传递问题，它的本质是订阅发布者模式，同一个事件发布组件发布了，订阅组件就能获得事件的改变摆脱了兄弟组件之间传值需要父组件转达，Vue事件实例，作为中间者不在页面上显示且具有vue的API 如 emit on ```js // bus.js =&gt; new 一个 Vue 实例 import Vue from 'vue' export default new Vue() // clickComponent.vue 相当于发布者, 在需要的组件中订阅就能进行通信 &lt;template&gt; &lt;div&gt; &lt;a href="#"class="click" :data-index="index" @click.prevent="doClick($event)"&gt;点我&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Bus from '@/common/bus.js' export default &#123; props: &#123; index: Number &#125;, methods: &#123; doClick (event) &#123; // console.log(event.target.dataset.index) Bus.$emit('getTarget', event.target.dataset.index) // this.$emit('global: getTarget', event.target.dataset.index) &#125; &#125; &#125; &lt;/script&gt; // showComponents.vue 另一个兄弟组件 进行订阅 &lt;template&gt; &lt;div&gt; &#123;&#123;html&#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Bus from '@/common/bus.js' export default &#123; data () &#123; return &#123; html: '还没有点击' &#125; &#125;, created () &#123; Bus.$on('getTarget', index =&gt; &#123; this.html = `第$&#123;index&#125;个元素` &#125;) //this.$on('global: getTarget', index =&gt; &#123; // this.html = `第$&#123;index&#125;个元素` // &#125;) &#125; &#125; &lt;/script&gt;``` 在node中有一个 `vue-event-proxy` npm包能够实现与EventBus同样的功能，需要安装该npm包, 并且在main.js中进行`引入 ` ```js import EventProxy from 'vue-event-proxy' Vue.use(EventProxy) // 激活使用 // 完成后即可以使用上面组件中js注释部分的代码代替Bus代码]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F07%2F15%2Fsorts%2F</url>
    <content type="text"><![CDATA[算法题如下数字: 35 99 18 76 12 桶排序 有[100] for初始化数组 将数字放到相应的位置 思想： 1234567891011121314151617181920212223242526272829303132333435 利用数组的下标是有序的,待排序的数字大小在下标的范围内，当数组下标等于要排序的数组时 用待排序的数字坐桶的下标 给相应项+1 类似于做标记的 myIdea:当下标等于待排序的数字大小 即输出下标 相当于输出较小的数字 ``` **时间复杂度:** 时间复杂度 循环 O(M+N) 一重循环最大值99 100，又一重循环N， 之后又有一层循环M 有值的桶子 嵌套循环 &gt;= 0 1 2 3有限的，&lt;N M+N 多层循环是最花时间M+N O(M+N+M+N)=O(2*(M+N)) O(M+N) **缺点:** 占物理内存，因为要分配M个元素的数组 - 冒泡排序 ```js// 冒泡排序 // 思想: 比较相邻的元素。如果第一个比第二个大，就交换两数顺序 const source_arr = [35,18, 99, 18, 76, 12];function bubbleSort(arr) &#123; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 let temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(source_arr)); 选择排序 第一重循环默认把 i 个作为最小值与后面 j 循环中的的数进行比较，也就是通过第二重循环与后面的值进行比较 12345678910111213141516171819202122// n^2// 找到数组中最小的值放在第一位，第二小的放在第二位...// 基址查询function SelectSort(arr) &#123; let len = arr.length for(let i = 0; i &lt; len; i++) &#123; let minIndex = i // 如果已经选择了， 前面的就一定是有序的 for( let j = i; j &lt; len; j++) &#123; if( arr[j] &lt; arr[minIndex]) &#123; // 循环和默认的最小值进行比较， 如果更小纪录下标 minIndex = j console.log(i, j) &#125; &#125; if(minIndex !== i) &#123; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]] &#125; &#125; return arr&#125;console.log(SelectSort([45,21,45,12,56,12,67,32,98])) 快排排序 因为采用了分治思想，所以快 形象的例子 三个数之间进行排序 a b c 再加递归 123456789101112131415161718192021222324252627// 简单排序： 冒泡、选择、插入 时间复杂度都是 n^2// 复杂排序： 快排、堆排、归并排序 时间复杂度都是 (log2^n)* n// 分治// 快排 log2(n)* n for循环 n次 // 1. 随机选择一个数组中的一个数作为一个基准 一般是中点 // 2. 其余数字跟他比较， 小的放左边 大的放右边 // 3. 利用递归的思想， 将左右两边的数重复以上两步function QuickSort(arr) &#123; // 这里是出口 当数组长度小于等于1的时候结束递归 if(arr.length &lt;= 1) &#123; return arr &#125; let pivotIndex = Math.floor(arr.length /2) // 把中间基准值从数组提出来 pivot = arr.splice(pivotIndex, 1)[0] // 选出相应位置的值 console.log(pivot) let left = [], right = [] for(let i = 0, len = arr.length ; i &lt; len; i++) &#123; if( arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return QuickSort(left).concat(pivot, QuickSort(right))&#125;console.log(QuickSort([85, 24, 63, 45, 17, 31, 78, 56]))]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【轻松集赞】写了个涉嫌混淆微信官方服务的小程序]]></title>
    <url>%2F2018%2F06%2F13%2FthumbsUp%2F</url>
    <content type="text"><![CDATA[发生背景：&nbsp;&nbsp;&nbsp;&nbsp;随着现在国内的社交软件用户群体的不断扩大，商家打广告的方式（套路）也越来越多了，每次走在大街上都可以看到商家打出来广告牌，”朋友圈点赞超过30享受六折优惠”。在上一次和女盆友出去万达吃个晚饭，终于我们也被这个活动诱惑了一下下，作为口袋钱不多又想好好吃一顿的大三狗，看看望着桌子上一大盆烤鱼，还在犹豫要不要点一份小龙虾的女朋友，还是选择了拍照发朋友圈然后挨个去群里叫亲朋好友点赞，麻烦了一堆好友，真是不好意思。&nbsp;&nbsp;&nbsp;&nbsp;吃饱喝足，两个人扶着腰走在路上炫’腹’、还是女盆友的提醒说，你不是会小程序吗，能不能写一个点赞的小程序来用。哎、还真是，我自己撸一个，说不定还能给其他人用。 初局雏形分析了一下小程序要的功能：1. 主要功能：点赞（想要多少赞就要多少赞） 2. 微信朋友圈部分功能 项目结构感觉这个小程序比较适合想要练手小程序和WeUI的盆友，所以细讲一点123456789&gt;├── assets 小程序所需的images icon ├── pages 页面目录 | ├── welcome 欢迎页面 | ├── index 内容发布操作页面| ├── mian &apos;朋友圈&apos; ├── style 页面的样式 及weui└── app.js 小程序逻辑 全局参数└── app.wxss 小程序公共样式└── app.json 项目的配置 需要注意的地方：微信朋友圈发布一张图片和多张图片图片宽高比例不一样 欢迎页面Welcome欢迎页的动画我很喜欢，也许是这一个小程序的亮点 各位，请原谅我、我也不知道怎么就变成横向的了 写在后面 小程序在模拟器上实现一些复杂功能和界面效果时，及时在移动设备上进行效果查看， 避免移动端上达不到预期效果，ios和android有时候在样式的显示上有时也会有不同]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC 浅谈]]></title>
    <url>%2F2018%2F06%2F13%2FBFC%2F</url>
    <content type="text"><![CDATA[写在前面 Block formatting context （块级格式化上下文） 页面文档由块block构成 每个block在页面上占据自己的位置使用新的元素构建BFC overflow：hidden | auto | scroll； 只要不为visible新的空间告诉浏览器，外面的环境影响不到我了 我重新来进行Block formatting 布局和定位 核心： 新的BFC，给出了新的不受外界影响的块级格式化环境 block 块级-&gt; 页面的基础 formatting context 格式化-&gt; 渲染 浏览器构建文档树的时候 布局和定位元素网页的定位（大） 文档流正常，浮动，定位，flex，table广义的定位 块级元素的定位 垂直的定位；行内元素 左右定位 通过内容来确定狭义的定位：float 浮动元素，在一行的开始或者结束flex 弹性布局position BFC 在正常的文档流里面重建一个新的上下文环境 BFC的约束规则 一、在浏览器进行页面元素布局的时候 同一个BFC的两个相邻的Box的margin 会重叠，与方向无关 破坏规则 创建新的BFC Context上下文的概念 如何创建BFC？=&gt;重新规划一个（独立）渲染区域 根元素body，天然是一个BFC overflow:hidden; float 不为none display:inline-block | table-cell |table-caption position:absolute | fixed 只要不为static 好像只剩块级元素和行内元素不是BFC 二、BFC的高度，浮动元素也要参与计算 在元素float之后脱离了文档流没有办法计算确切高度，这种情况我们称之为高度塌陷。解决高度塌陷的前提就是能识别并包含到浮动元素。而BFC就有这个特性，所以BFC也可以计算浮动元素的高度。新建BFC让浮动元素也参与计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 &lt;style&gt; *&#123;padding: 0;margin: 0;&#125; .par&#123; border: 5px solid #fcc; width: 300px; /*这里的overflow并不是为了超出则隐藏，而是为了创建一个BFC*/ /* overflow: hidden; */ display: inline-block; &#125; .child&#123; border: 5px solid #f66; width: 100px; height: 100px; float: left; /* clear: both; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 网页的定位（大） 文档流正常，浮动，定位，flex，table --&gt; &lt;div class="par"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;``` - 三、每个元素的左边，要与包含盒子的左边相接触- 四、BFC的区域不会与float box重叠 ```html &lt;style&gt; *&#123;padding: 0;margin: 0;&#125; .aside&#123; float: left; width: 100px; height: 150px; background-color: #ff6666; &#125; .main&#123; height: 200px; background: #ffcccc; /* clear: left; */ overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 自适应两栏式布局 类似于flex：1； aside 和 main 处于同一BFC（body）下 BFC布局规则3 规则4 --&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/body&gt;``` ```html/*BFC在三栏式布局中的应用*/ &lt;style&gt; *&#123;padding: 0;margin: 0;&#125; .container&#123; height: 200px; &#125; .left,.right,.center&#123; height: 200px; &#125; .left&#123; background: pink; float: left; width: 180px; &#125; .right&#123; background: lightblue; width: 180px; float: right; &#125; .center&#123; background: yellow; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 三栏式布局 --&gt; &lt;div class="container"&gt; &lt;!-- 页面的结构与呈现效果不一致？想一下 --&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right&lt;/div&gt; &lt;div class="center"&gt;Center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;``` **注意：** &gt; 通过 overflow:hidden将元素转换为BFC，固然可以解决高度塌陷的问题，但是大范围的应用在布局上是肯定是行不通的，毕竟overflow会造成溢出隐藏的问题，特别是与JS交互的效果时。 那有没有一个更好的高度检测方法呢？答案是有的，就是我们经常用到的clearfix。 ```css.clearfix:after&#123; content:''; display:table; clear:both&#125;.clearfix&#123; *zoom:1;/* IE6,7不支持BFC，所以需要通过专有的CSS属性，触发hasLayout。*/&#125; 关于zoom:1]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何手动实现一个New操作]]></title>
    <url>%2F2018%2F06%2F13%2Fnew%2F</url>
    <content type="text"><![CDATA[写在前面 在所有的前端面试中常常喜欢考面试者如何手写一个new操作符，作为在准备秋招的大三党，我也要考虑这些。那么我们先看看new操作符都干了什么事情，有哪些操作？通过下面的代码来进行思考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 新建一个类（构造函数）function Otaku(name, age) &#123; this.name = name; this.age = age; // 自身的属性 this.habit = 'pk';&#125;// 给类的原型上添加属性和方法Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;// 实例化一个person对象const person = new Otaku('乔峰',5000);person.sayYourName();console.log(person);//打印出构造出来的实例``` ![控制台打印结果](http://p9utic4op.bkt.clouddn.com/new.png) ## 解析 从控制台打印出来的结果我们可以看出new操作符大概做了一下几件事情： 1. 返回（产生）了一个新的对象 2. 访问到了类Otaku构造函数里的属性 3. 访问到Otaku原型上的属性和方法 并且设置了this的指向（指向新生成的实例对象） 通过上面的分析展示，可以知道new团伙里面一定有Object的参与，不然对象的产生就有点说不清了。 先来边写写： ```js// 需要返回一个对象 借助函数来实现new操作 // 传入需要的参数： 类 + 属性const person = new Otaku('乔峰',5000);const person1 = objectFactory(Otaku, '鸠摩智', 5000);// 开始来实现objectFactory 方法 function objectFactory(obj, name, age) &#123;&#125;// 这种方法将自身写死了 如此他只能构造以obj为原型，并且只有name 和 age 属性的 obj// 在js中 函数因为arguments 使得函数参数的写法异常灵活，在函数内部可以通过arguments来获得函数的参数function objectFactory() &#123; console.log(arguements); //&#123; '0': [Function: Otaku], '1': '鸠摩智', '2': 5000 &#125; // 通过arguments类数组打印出的结果，我们可以看到其中包含了构造函数以及我们调用objectfactory时传入的其他参数 // 接下来就是要想如何得到其中这个构造函数和其他的参数 // 由于arguments是类数组，没有直接的方法可以供其使用，我们可以有以下两种方法: // 1. Array.from(arguments).shift(); //转换成数组 使用数组的方法shift将第一项弹出 // 2.[].shift().call(arguments); // 通过call() 让arguments能够借用shift方法 const Constructor = [].shift.call(arguments); const args = arguments; // 新建一个空对象 纯洁无邪 let obj = new Object(); // 接下来的想法 给obj这个新生对象的原型指向它的构造函数的原型 // 给构造函数传入属性，注意：构造函数的this属性 // 参数传进Constructor对obj的属性赋值，this要指向obj对象 // 在Coustructor内部手动指定函数执行时的this 使用call、apply实现 Constructor.call(obj,...args); return obj;&#125;``` - 上面的代码注释太多，剔除注释以后的代码：```js function objectFactory() &#123; let Constructor = [].shift.call(arguments); const obj = new Object(); obj.__proto__ = Conctructor.prototype; Constructor.call(obj,...arguments); return obj; &#125;``` - 还有另外一种操作： ```jsfunction myNew(Obj,...args)&#123; var obj = Object.create(Obj.prototype);//使用指定的原型对象及其属性去创建一个新的对象 Obj.apply(obj,args); // 绑定 this 到obj, 设置 obj 的属性 return obj; // 返回实例&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WePY 上手]]></title>
    <url>%2F2018%2F06%2F04%2Fwepy%2F</url>
    <content type="text"><![CDATA[来自微信官方的小程序组件开发框架介绍WePY (发音: /&apos;wepi/)是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。 类Vue开发风格 支持自定义组件开发 支持引入NPM包 支持Promise 支持ES2015+特性，如Async Functions 支持多种编译器，Less/Sass/Stylus/PostCSS、Babel/Typescript、Pug 支持多种插件处理，文件压缩，图片压缩，内容替换等 支持 Sourcemap，ESLint等 小程序细节优化，如请求列队，事件优化等 安装使用安装（更新）wepy命令行工具1npm install wepy-cli -g 生成开发实例1234567891011121314npm init standard projectName``` 生成src的目录 开发在此目录进行开发### 安装依赖 ```jsnpm install``` 将所有项目和开发时（package.json）所需要的依赖进行安装### 开启实时编译```jswepy build --watch``` 生成dist目录、并实时监听src目录下的修改且编译到dist目录中 ### WePY项目目录结构 ├── dist 小程序运行代码目录（该目录由WePY的build指令自动编译生成，请不要直接修改该目录下的文件）├── node_modules├── src 代码编写的目录（该目录为使用WePY后的开发目录）| ├── components WePY组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy 可复用的WePY组件a| | └── com_b.wpy 可复用的WePY组件b| ├── pages WePY页面目录（属于完整页面）| | ├── index.wpy index页面（经build后，会在dist目录下的pages目录生成index.js、index.json、index.wxml和index.wxss文件）| | └── other.wpy other页面（经build后，会在dist目录下的pages目录生成other.js、other.json、other.wxml和other.wxss文件）| └── app.wpy 小程序配置项（全局数据、样式、声明钩子等；经build后，会在dist目录下生成app.js、app.json和app.wxss文件）└── package.json 项目的package配置` 开发者工具导入项目使用微信开发者工具新建项目，本地开发选择生成的dist目录，会自动导入项目目录配置 WePY官方文档]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序笔记总结]]></title>
    <url>%2F2018%2F05%2F16%2FwxNote%2F</url>
    <content type="text"><![CDATA[小程序的项目架构 基础组件 地图 视图容器 组件 事件数据绑定template 只支持wxml wxss 模板 模块化不支持wx:for wx:key wx:if样式导入 和 模块引入数据缓存// 设置缓存 缓存是永久存在的 没有时效 上限最大不能超过10M // wx.setStorageSync (&quot;collect&quot;, true); // 修改缓存，同名 wx.setStorageSync(&apos;key&apos;,{ game:&quot;风暴英雄&quot;, developer:&apos;暴雪&apos; }); // var postCollected=wx.getStorageSync(&quot;collected&quot;); }, collectionTap(event){ let game = wx.getStorageSync(‘key’); console.log(game.developer); }, shareTap(event){ // wx.removeStorageSync(‘key’); // 清除所有缓存 wx.clearStorageSync(); },]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>WXApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript函数]]></title>
    <url>%2F2018%2F05%2F09%2Ffunction_note%2F</url>
    <content type="text"><![CDATA[函数 函数用于指定对象的行为，在其中包含一组语句。用于代码复用、信息隐藏、和组合调用。 函数对象JavaScript 中的函数就是对象。函数对象连接到Function.prototype（该原型对象本身连接到Object.prototype）。每个函数对象在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。 函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值即为该函数对象。1234567891011121314151617181920212223242526272829 function add(a,b)&#123; return a+b; &#125;``` 因为函数是对象，所以可以像任何其他的值一样被使用。函数可以保存在变量、对象和数组中。函数可以被当做参数传递给其他函数，函数也可以再返回函数。函数也可以拥有方法。函数的与众不同之处在于可以被调用。 ### 函数字面量 函数对象通过函数字面量来创建。函数字面量包含4部分，分别是：保留字 function、函数名、参数、花括号中的语句。```js var add = function(a, b) &#123; return a + b &#125; ``` ### 调用 调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，还有两个附加参数：`this`和`arguments`。参数this在面向对象编程中非常重要，它的值取决于调用的模式。实参和形参个数不匹配时，不会有运行时错误。实参过多时，超出的实参被忽略。形参过多时，缺失的值被替换为undefined。 - 方法调用模式 当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，`this被绑定到该对象`,通过this可以对该对象的属性和方法进行调用和操作。 ```js var myObject = &#123; text: hello, say:function(msg)&#123; console.log(this.text + msg); &#125; &#125; myObject.say(world); 函数调用模式当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。此时this被绑定到全局对象。即时是内部函数也会将this绑定到全局对象。this的指向问题 作用域不一样 this的指向就不一样,可以在函数内创建一个属性并赋值为this来解决这个问题,一般通过var that = this; 1234567891011121314var add = function(a, b) &#123; return a + b&#125;myObject.double = function() &#123; var that = this var helper = function() &#123; that.value = add(that.value, that.value) &#125; helper()&#125;myObject.double()console.log(myObject.value) //8 12345678910111213141516171819202122232425 attachEvent: function () &#123; // attachEvent函数的作用域 // js 里面this总会指向什么 // 对象的方法被执行时 this指向对象 // console.log(this); var that = this; this.staticElement.addEventListener('click', function () &#123; // 这个函数被执行时，并不是对象的方法，而是匿名函数，作为事件处理函数来执行，this会指向事件发生元素 // this的指向跟函数的调用方式有关 // this的指向问题 作用域不一样 this的指向就不一样 // 作用域 事件的回调函数 // console.log(this); // alert(that.value); that.convertToEdit(); &#125;, false); this.filedElement.addEventListener('keydown', function (evt) &#123; // 在事件发生的一刹那 会产生一个临时事件对象 console.log(evt); if (evt.keyCode == 13) &#123; that.staticElement.innerHTML = this.value; console.log(that.staticElement.innerHTML); that.convertToText(); &#125; &#125;, false)&#125; 构造器调用模式JavaScript是一门基于原型继承的语言。对象可以直接从其他对象继承属性。该语言是无类型的。如果在一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。 1234567891011121314//创建构造器函数var Quo = function(string) &#123; this.status = string&#125;//给Que的所有实例提供一个公共方法Quo.prototype.getStatus = function() &#123; return this.status&#125;//实例化var myQuo = new Quo('confused')console.log(myQuo.getStatus()) //confused Apply 调用模式apply方法让我们构建一个参数数组传递给调用函数。他也允许我们选择this的值。apply方法接受两个参数，第一个是要绑定给this的值，第二个是参数数组。 123456789101112131415161718192021222324 var arr = [3, 4] var sum = add.apply(null, arr) console.log(sum) //7 var statusObject = &#123; status: 'hello' &#125; var status = Quo.prototype.getStatus.apply(statusObject) console.log(status) //hello``` ### 参数 当函数被调用时，会得到一个`arguments`数组。通过此参数可以访问所有它被调用时传递给它的`参数列表`，包括那些没有被分配给函数声明时定义的形参的多余参数。这使得编写一个无须指定参数个数的函数成为可能。```js var sum = function() &#123; var i, sum = 0 for (i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; return sum &#125; console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)//45 因语言的设计错误，arguments并不是一个真正的数组。是一个“类似数组”的对象。有length属性，但没有任何数组的方法。 返回函数执行时遇到关闭函数体的}时结束。然后把控制权交还给调用该函数的程序。 return可以使函数提前返回，当return语句执行时函数立即返回不在执行余下的语句。 函数总是会返回一个值，若没有指定，则返回undefined。 若函数调用时在前面加上了new前缀，且返回值不是一个对象的时候，则返回this（该新对象）。 闭包作用域的好处是内部函数可以访问定义他们的外部函数的参数和变量（除了this和arguments）。12345678910var quo = function(status) &#123; return &#123; get_status: function() &#123; return status; &#125; &#125;&#125;var myQuo = quo('amazed')console.log(myQuo.get_status()) //amazed 狭义的说，返回的那个对象即闭包，它里面的方法可以访问它被创建时所处的上下文环境。status访问的就说对象中的status属性本身,通过闭包可以让一个局部变量驻留在内存中 避免在循环中创建函数，容易引起混淆。可以现在循环之外创建一个辅助函数，让辅助函数在返回一个绑定了当前i值的函数，这样就不会导致混淆了。 回调将一个函数作为参数，一旦接收到响应，再调用这个函数。12345 fs.readFile('demo/02.js','utf8',(error,data)=&gt;&#123; if(error) throw error; //在异步中的错误不能被捕获 通过throw error进行错误的捕获 console.log(data) &gt;&gt;a.txt;&#125;); 模块可以用函数和闭包构造模块。模块是一个提供接口却隐藏与实现的函数或者对象 模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可访问到的地方。123456789101112131415161718192021var numberCal = (function() &#123; var half = function(n) &#123; return n / 2 &#125; var double = function(n) &#123; return n * 2 &#125; var tribble = function(n) &#123; return n * 3 &#125; return &#123; half: half, double: double, tribble: tribble &#125;&#125;())console.log(numberCal.half(5)) //2.5console.log(numberCal.half(6)) //3console.log(numberCal.double(7)) //14console.log(numberCal.tribble(7)) //21 级联如果让方法返回this而不是默认的undefined，就可以启用级联，即连续调用。 记忆函数可以将先前操作的结果记录在某个对象或者数组里，从而避免无谓的重复运算。这种优化被称为记忆（memoization）。]]></content>
      <categories>
        <category>js语言精粹</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让div在屏幕上居中（水平居中+垂直居中）的方法总结]]></title>
    <url>%2F2018%2F05%2F09%2FcssCenter%2F</url>
    <content type="text"><![CDATA[html代码如下： &lt;div class="book"&gt; &lt;div class="front-cover"&gt; &lt;/div&gt; &lt;/div&gt; Css居中方法 （敲黑板）重点 首先将元素设置成为绝对定位，然后距顶部和左各50%，此时的元素还不是居中的，因此需要通过一定的偏移将其移到理想位置，两种方法的主要思想都是一样的，第一种通过margin-left和margin-top移动元素自身宽高的一半，另一种通过css3的属性transform的translate方法平移元素自身宽高的一半， 代码展示如下： body { color: #ffffff; background: #444444; } .book { width: 300px; height: 300px; position: absolute; top: 50%; left: 50%; /* 第一种 */ /* 兼容性 未使用css3, ie678 */ /* margin-left: -150px; */ /* margin-top: -150px; */ /*第二种*/ -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); } 两种方法第一种的兼容性更加的好一些，因为其中没有使用Css3的属性 对于ie678的兼容比较友好]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F05%2F09%2FURL%2F</url>
    <content type="text"><![CDATA[title: 输入URL之后date: 2018-05-03tags: ‘’ categories: 前端有的研究]]></content>
  </entry>
  <entry>
    <title><![CDATA[stylus之变量与mixin]]></title>
    <url>%2F2018%2F05%2F09%2Fmixin%2F</url>
    <content type="text"><![CDATA[混合书写(Mixins) 变量 在stylus中 可以将常用的样式像表达式中变量赋值一样保存给一个变量、如下： 12345678/*进行变量的声明*/bg_color = #123456;box_size = 100px;/* 使用 */.box background-color bg_color width box_size height box_size 编译后： 12345.box &#123; background-color: #123456; width: 100px; height: 100px; &#125; 属性查找Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下： 12345678#logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2) 在stylus中可以不使用这里的变量w和h, 而是简单地前置@字符在属性名前来访问该属性名对应的值：12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 混合书写 混合书写和函数定义方法一致，但是应用却大相径庭。 例如，在书写Css3样式时我们经常要进行兼容性处理，需要在属性前加上相应的前缀，下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。123456789101112131415161718192021222324 bg_color = #123456; box_size = 100px; /*定义mixin*/ border-radius(n) -webkit-border-radius n -moz-border-radius n -ms-border-radius n -o-border-radius n border-radius n .box background-color bg_color width box_size height box_size border-radius(5px)``` 进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式,这样就可以給属性传递多个值。 ```cssborder-radius() -webkit-border-radius arguments -moz-border-radius arguments -ms-border-radius arguments -o-border-radius arguments border-radius arguments Stylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。例如，-webkit-{‘border’ + ‘-radius’}等同于-webkit-border-radius. 再进一步，在stylus中我们还可以对border-radius再做进一步的处理 类似与js中的函数封装 ，如下(这样对于任何需要做兼容性处理的属性 我们只需要调用两次mixin出入所需参数，大大的简化了一下琐碎代码工作): 12345678910111213141516 vendor(prop,args) -webkit-&#123;prop&#125; args -moz-&#123;prop&#125; args -ms-&#123;prop&#125; args -o-&#123;prop&#125; args &#123;prop&#125; argsborder-radius(n) vendor('border-radius',arguments)box-shadow(n) vendor('boa-shadow',arguments).box background-color bg_color width box_size height box_size border-radius(5px) 编译后： 123456789101112131415 .box &#123; background-color: #123456; width: 100px; height: 100px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; -webkit-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); -moz-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); -ms-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); -o-box-shadow: 1px 1px 10px rgba(0,0,0,0.5); box-shadow: 1px 1px 10px rgba(0,0,0,0.5);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css3属性]]></title>
    <url>%2F2018%2F05%2F04%2FCss3%2F</url>
    <content type="text"><![CDATA[text-shadow属性介绍: `text-shadow`属性可以给页面上的文字增添阴影效果，`text-shadow`在Css2.1的时候是 被删除了的一个属性，但是呢在3.0的Css中又恢复了使用 使用方法 1&gt; text-shadow : length length length color 注：前两个参数在使用的时候必须给定 第一个length表示阴影离开文字横方向的距离 第二个length表示阴影离开文字纵方向的距离 第二个length表示阴影模糊半径 即模糊范围 color 表示阴影颜色 可以放在三个length之前 也可以放在之后 如果不给值 则使用元素默认color $ 指定多个阴影： 每个阴影用逗号隔开 1text-shadow : 15px 15px 5px #000,30px,30px,5px #f60; background-size属性介绍: 在Css3中可以使用background-size来指定背景图像的尺寸 使用方法 1background-size: auto || length || percentage || cover || contain auto: 默认值 保持背景图片的原始宽高比 length: 设置背景图片的宽度和高度，如果只设置一个值，则第二个值会被设置为auto 按宽高比进行放大缩小 percentage: 以父元素的百分比来设置宽度和高度，如果只设置一个值 同上 cover: 此值是将图片放大，以适合铺满整个容器，这个主要用在当图片小于容器又无法使用background-repeat来实现，就可以采用cover将背景图片放大到适合容器的大小，但是会使图片失真 contain: 与cover相反，将背景图片缩小以适合铺满整个容器，这个主要用在当背景图片大于元素容器时，而又需要将背景图片全部显示出来，就可以用contain将图片缩小到适合容器的大小，这种方法同样会使图片失真 在一个元素中显示多个背景图片介绍:在Css3一个元素可以显示多个背景图像，还可以将多个背景图像进行重叠显示，这样对背景中所用素材调整变得更加容易。使用方法 background-image:url(1.png),url(2,png),url(3.png); 图层的排序方法: 浏览器中显示时叠放的顺序是从上往下指定的，第一个图片放在最上面，最后指定的放在下面 Css3的变形功能transform属性介绍: 在Css3中可以利用transform属性来实现文字或图像的旋转、缩放、倾斜、和移动。但是需要做兼容性处理，如下 1234-webkit-transform: rotateX(60deg);-moz-transform: rotateX(60deg);-ms-transform: rotateX(60deg); /*IE9*/-o-transform: rotateX(60deg); rotate(旋转)： rotate(60deg);顺时针旋转 deg是Css3中的角度单位 1-webkit-transform: rotateX(60deg); rotateX(angle) rotateY(angle) rotateZ(angle) 绕对应的轴进行3D旋转 rotate3D(X,Y,Z,deg) 定义 3D 旋转 scale(缩放)：transform:scale(值) 值所指的是缩(小)放(大)倍率 如果值为负数并没有效果 纯属无聊 scale(x,y) 使元素在x轴 y轴方向同时缩放 scaleX(.5) 你应该懂得 scaleY(.5) 同上 skew(倾斜)transform:skew(deg) 倾斜角度 skew(x,y) 元素在水平和垂直方向上同时倾斜 只有一个参数时，只在水平方向上倾斜 skewX(x) 元素仅在水平方向倾斜 skewY(y) 元素在垂直方向倾斜 translate(值) 指定移动的距离 负值即反方向移动 translate(x,y);在x轴和y轴同时移动，只有一个参数时，仅在水平方向移动; translateX(x);x轴方向移动-translateY(y);y轴方向移动 transform-origin 改变元素基点 属性使用：transform-origin:bottom; 各个基点参考如图： 对一个元素使用多种变形的方法： transform：方法一，方法二，方法三..; 12 /*同样也需要做兼容性处理*/transform: translate(50px),rotate(60deg),scale(2); Css3的动画功能demo transition 支持从一个属性平滑过渡到另外一个属性 语法: 1transition: property duration timing-function delay; transition 主要包含四个属性值: 执行变换的属性: transition-property,属性规定应用过渡效果的CSS属性的名称。(当指定的CSS属性改变时，过渡效果将开始)值有三个类型: A、`none` 没有属性会获得过渡效果。 B、`all`所有属性都将获得过渡效果。 C、`property`定义应用过渡效果的CSS 属性名称列表，列表以逗号分隔。 变换延续的时间: transition-duration规定完成过渡效果需妻花费的时间(以秒或毫秒计》，默认值0没有效果 在延续时间段，变换的速率变化transition-timing-function值:123456A 、ease: (逐渐变慢) 默认值，ease函数等同于贝塞尔曲线(0.25,0.1,0.25,1.0). B、linear: (匀速)，linear 函数等同于贝塞尔曲线(0.0,0.0,1.0,1.0). C、ease-in: (加速)，ease-in 函数等同于贝塞尔曲线(0.42,0,1.0,1.0). D、ease-out: (减速)，ease-out 函数等同于贝塞尔曲线(0,0,0.58,1.0). E 、ease-in-out : (加速然后减速)，ease-in-out 函数等同于贝塞尔曲线(0.42,0,0.58,1.0) F、cubic-bezier(n,n,n,n)在cubic-bezier 函数中定义自己的值。可能的值是0 至1之间的数值。 animation 支持通过关键帧的指定来在页面上产生更复杂的动画效果用 transition和Animations的区别 : 1`transition`和`Animations`的区别在于，`transition`只能通过指定属性的开始值与结束值，然后通过两属性值之间进行垂滑过渡的方式来实现动画效果，所以transition不能实现复杂的动画效果，而Animations功能是是通过关键幀以及每个关键帧中的属性值来实现更为复杂的动画效果。 Animations的使用方法:参考我的飞机Demo更好哦@-webkit-keyframes 关键帧合集名称{ 创建关键帧的代码 } 0%~100%{本关键帧中的样式}关键帧创建好了之后，还要在元素的样式中使用该关键帧。方法如下: 123456789101112131415161718192021 元素&#123; - webkit-animation-name :关键帧合集名称 ; - webkit-animation-duration:5s ; - webkit-animation-timing-function :linear;-webkit-animation-iteration-count:infnite &#125; ``` `-webkit-animation-name`指定合集名称， `-webkit-animation-duration`整个动画执行完成所需的时司、需要的时间， `-webkit-animation-timing-function`实现动画的方法 `-webkit-animation-iteration-count`属性的属性值设定为某个整数值，那么这个动画播放的次数就等于这个整数值(infinite是无限循环播放)。 3、实现动画的方法: A、linear: 匀速进行. B、ease-in: 开始速度很慢，然后沿曲线进行加快， C、ease-out: 开始速度很快，然后沿着曲线进行减速. D、ease: 开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速， E、ease-in-out: 开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速.也可以以合集的形式进行样式书写： ```animation: name duration timing-function delay iteration-count direction;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完整的URL请求页面过程]]></title>
    <url>%2F2018%2F05%2F03%2FURL2%2F</url>
    <content type="text"><![CDATA[当我们在网页浏览器（Web browser）的地址栏中输入URL时，Web页面是如何呈现的？就让我们来聊聊从用户输入到页面加载完成的过程中都发生了什么事情。 一、请求过程简介用户输入URL大概发生了以下一些事： (1) DNS域名解析到对应的IP地址； (2) 浏览器向Web服务器发送一个HTTP请求； (3) 服务器的永久重定向响应; (4) 浏览器跟踪重定向地址; (5) 服务器处理请求，并返回一个HTTP响应; (6) 浏览器显示HTML;[1]: 请求过程 二、请求过程详解1. DNS查找IP地址DNS是域名系统（Domain Name System）的缩写，是因特网的一项核心服务，是和HTTP协议位于应用层的协议，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 (一) DNS 查找过程 浏览器缓存 – 浏览器会缓存DNS记录一段时间，但是操作系统并没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。 系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。 路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。 ISP DNS缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。 递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从.com顶级域名服务器到example的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。 (二) DNS进行域名解析的过程 客户端发出 DNS 请求翻译 IP 地址或主机名； DNS 服务器在收到客户端的请求后，检查 DNS 服务器的缓存，若查到请求的地址或名字，即向客户端发出应答信息； 若没有查到，则在数据库中查找，若查到请求的地址或名字，即向客户端发出应答信息； 若没有查到，则将请求发给根域 DNS 服务器，并依序从根域查找顶级域，由顶级查找二级域，二级域查找三级，直至找到要解析的地址或名字。然后，向客户端所在网络的 DNS 服务器发出应答信息，DNS 服务器收到应答后，先在缓存中存储，然后，将解析结果发给客户端。 若没有找到，则返回错误信息。 2. HTTP请求 (一) 三次握手建立TCP连接 在 http 工作开始之前，浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的。该协议与 IP 协议共同构建 Internet ，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。http 是比 TCP 更高层次的应用层协议。根据规则，只有低层协议建立之后才能进行更高次层协议的连接。因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80 。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接： 1. 第一次握手：建立连接时，客户端发送 SYN 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers） 2. 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； 3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，完成三次握手。 (二) 完成三次握手，客户端与服务器开始传送数据。 一旦建立了 TCP 连接，浏览器就会向服务器发送 http 请求命令。浏览器发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息。此后，浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。[4]: 完成三次握手 (三) 四次挥手终止连接 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动。一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 1. 第一次挥手：TCP 客户端发送一个 FIN，用来关闭客户端到服务器的数据传送（客户端向服务器发送一个断开连接的请求）; 2. 第二次挥手：服务器收到这个 FIN，它发回一个 ACK（确认收到请求的信号），确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号 (服务器接收到请求之后，发送确认接受到请求的信号); 3. 第三次挥手：服务器关闭客户端的连接，发送一个 FIN 给客户端 (服务器向客户端发送断开的通知); 4. 第四次挥手：客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1 (客户端接收到断开的通知后断开连接，并反馈一个确认信号，服务器接收到确认信号断开连接)。 3. 服务器的永久重定向响应服务器会给浏览器返回一个301永久重定向响应服务器给浏览器响应一个 301 永久重定向响应，这样浏览器就会访问http://www.facebook.com/ 而非 http://facebook.com/ 。为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。你看，如果一个页面有两个地址，就像 http://www.igoro.com/ 和 http://igoro.com/ ，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道 301 永久重定向是什么意思，这样就会把访问带 www 的和不带 www 的地址归到同一个网站排名下。还有一个原因是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。 4. 浏览器跟踪重定向地址浏览器通过 301 知道 http://www.facebook.com 才是要访问的正确地址，所以它会发送另一个获取请求。 5. 服务器处理请求，并返回一个HTTP响应服务器接收到获取请求并处理，然后返回一个HTTP响应 6. 页面渲染现代浏览器渲染页面的过程是这样的：解析 html 以构建 DOM 树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树DOM 树是由 html 文件中的标签排列组成。 渲染树是在 DOM 树中加入 css 或 html 中的 style 样式而形成。渲染树只包含需要显示在页面中的 DOM 元素，像 &lt;head&gt;元素或 display 属性值为 none 的元素都不在渲染树中。在浏览器还没接收到完整的 html 文件时，它就开始渲染页面了。 在遇到外部链入的脚本标签、样式标签、图片时，会再次发送 http 请求重复上述的步骤。在收到 css 文件后，会对已经渲染的页面重新渲染，加入它们应有的样式。图片文件加载完，立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。]]></content>
      <tags>
        <tag>🌝</tag>
        <tag>面试</tag>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css3之Flex布局]]></title>
    <url>%2F2018%2F05%2F02%2Fflexbox%2F</url>
    <content type="text"><![CDATA[Flex(flexible box) 弹性布局传统的布局解决方案，基于盒模型，通过 css中的display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 概念 任何容器都可以设为flex布局 采用flex布局的元素即为flex container，其子元素为容器成员(flex item) 设为flex布局以后，子元素的float/clear/vertical-align属性将会失效 主轴和交叉轴 容器默认存在水平主轴main axis和垂直的交叉轴cross axis flex-item排列的方向是主轴 flex-container容器属性 flex-direction决定主轴的方向(同时也是flex-item的排列方向) flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴是水平方向，flex-item水平从左往右排列 column : 主轴呈垂直方向,从上边沿向下排列 reverse参数: 将起始与终点进行互换 flex-wrap 属性定义如果在一条轴线上排不下，换行的规则 flex-wrap：nowrap | wrap | wrap-reverse nowrap（默认值）：不换行 wrap : 自然换行 直接将多余的元素从下一行开始排列 wrap-reverse: 将第一行排列到下方 flex-flow 是flex-direction和flex-wrap的简写，默认值为row nowrap justify-content:定义flex-item在主轴main-axis上的对齐方式 justify-content: flex-start | flex-end | center | space-between | space-around flex-start（默认值）：左对齐； flex-end右对齐； center居中； space-between：两端对其，flex-item间的间隔距离相等 space-around：每个flex-item两侧的间隔相等，相当于设置左右margin值相等 align-items: 定义flex-item在交叉轴的对齐方式 align-items: flex-start | flex-end | center | baseline | strecth。五个取值与交叉轴方向有关 flex-start|flex-end|center和flex-direction一样，只不过是在交叉轴起点、终点、中点对齐； baseline：flex-item的第一行文字的基线对齐 stretch（默认值）：如果flex-item没有设置高度或者值为auto，将占满整个容器高度 align-content：如果容器内出现多跟轴线（即出现wrap），定义主轴在交叉轴上的对齐方式，只有一根轴线时不起作用 align-content: flex-start | flex-end | center | space-between | space-around | stretch stretch（默认值）：轴线沾满整个交叉轴 space-between：与交叉轴两端对齐，轴线间的间隔平均分布 space-around：每根轴线两侧的间隔相等 flex-start：与交叉轴起点对其 flex-item项目的属性 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大.&nbsp; &nbsp; &nbsp;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。负值对该属性无效。 flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] flex-basis align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题个性化配置]]></title>
    <url>%2F2018%2F04%2F26%2Fnextconfig%2F</url>
    <content type="text"><![CDATA[看到一些大神的next博客站点很酷 那到底是怎么实现的呢 经过一番的倒腾，终于将一些使用且比较酷的功能添加到自己的博客中 主要添加的功能有： 在右上角或者左上角实现fork me on github 添加RSS· 添加动态背景· 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 主页文章添加阴影效果 在网站底部加上访问量 添加菜单分类页面· 首页实现文章内容截断（展示阅读全文） 网站底部字数统计 添加 README.md 文件· 隐藏网页底部powered By Hexo / 强力驱动 添加来必力评论 Livere· DaoVoice 在线联系 添加站内搜索0 实现fork me on github 1.修改头像并配置头像样式 编辑 ·主题配置文件·， 修改字段 `avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 将头像图片放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 或者使用图片的在线地址 2.设置博客背景动画NexT 自带两种背景动画效果：编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：如下、 #canvas_nest canvas_nest: true //开启动画 #three_waves three_waves: false //关闭动画 3.添加RSS在blog目录下安装hexo-generate-feed 然后打开z主题配置文件,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) #Set rss to false to disable feed link. #Leave rss as empty to use site&apos;s feed link. # Set rss to specific value if you have burned your feed already. rss: /atom.xml 4.在网站底部加上访问量 有点不想写了 5.网站底部字数统计&nbsp; 修改如下部分 #Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 在适当的位置添加以下页面代码 6.添加README.md 每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为skip_render:README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 7.添加菜单分类/标签页面&nbsp; 在hexo站点目录下 使用hexo new page 新建一个页面 命名为tags 如下： hexo new page tags 此时会在hexo &gt; source文件夹中会生成一个tags文件夹。 编辑tags文件夹下面的.md文件 &nbsp; 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: menu:home: / || homearchives: /archives/ || archivetags: /tags/ || tags &nbsp; 注：||之前的值是目标链接，之后的是页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。 8.添加livere来必力评论模块注意：最新版 hexo-theme-next 已经包含 LiveRe 插件，下载最新版本，配置 livere_uid 即可使用 获取livere_uid步骤 注册 LiveRe 进入 LiveRe，注册账号。 LiveRe 有两个版本： City 版：是一款适合所有人使用的免费版本；Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。City版就够了。安装，获取 uid： 填写完成后，进入到 管理页面 -&gt; 代码管理 -&gt; 一般网站 代码中，data-uid 即为所需 uid 添加 LiveRe 插件 首先在 _config.yml 文件中添加如下配置： #Support for LiveRe comments system. #You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 其中 livere_uid 即上一步获取到的 uid。其他的设置在最新版中都不需要配置啦 所以说程序员还是要用新的潮的东西 9.设置网站图标 具体方法实现 找一张（32*32）的ico图标，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改`主题配置文件`,下面就是图标配置代码修改即可： favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 10.站内博客搜索添加百度/谷歌/本地 自定义站点内容搜索. 1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： npm install hexo-generator-searchdb –save 2.编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 3.编辑 主题配置文件，启用本地搜索功能： &gt; #Local search local_search: enable: true 11.首页文章内容截断编辑主题配置文件 如下设置则会开启自动截断功能 #Automatically Excerpt. Not recommend. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo中安装next主题]]></title>
    <url>%2F2018%2F04%2F25%2Fnext_install%2F</url>
    <content type="text"><![CDATA[倒腾了一天半终于自己实现了一个还不错的博客，在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。如果没有搭建好自己的hexo+git pages博客界面可以看我另外一篇经验分享 **说明**：在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题next目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 下载主题 下载方式： 1.在theme文件夹中将主题包克隆到本地，并将文件名`hexo-theme-next`改成`next` git clone https://github.com/iissnan/hexo-theme-next themes/next 2.前往Next[发布页面][1]将`sourcecode`下载到本地，解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（`hexo-theme-next-0.4.0`）更改为 `next`。 启用Next 当 克隆/下载 完成后，打开 站点配置文件， 找到 `theme` 字段，并将其值更改为`next`。 验证主题是否应用 1. NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 最好使用 `hexo clean` 来清除 Hexo 的缓存。 2. 执行`hexo generate` 生成博客 3. 执行`hexo server`启用本地服务器 在本地可以直接查看修改以后的效果 &gt;`INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to` 使用浏览器进行访问http://0.0.0.0:4000/ 修改主题样式scheme Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 #Schemes #scheme: Mist scheme: Muse #scheme: Pisces #scheme: Gemini 其他基本配置 打开站点配置文件 可以像我一样进行基本设置 每个冒号后面必须与内容用空格分割 #Sitetitle: HeiLiu //站点titlesubtitle: 有一句Hello World想要对你说description: 程序员 大学本科keywords:author: 刘江龙language: zh-Hans //设置语言timezone: Asia/Shanghai //时间 #Deployment Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/HeiLiu/HeiLiu.github.io.git branch: master]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对数组去重的几种方法]]></title>
    <url>%2F2018%2F04%2F22%2FArrayUnique%2F</url>
    <content type="text"><![CDATA[面试经常问的一道题JS对数组去重的几种方法 (前面六种方法是普通数组，最后一种是对象数组) 方法一： 最原始的方法，定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。1234567891011121314var arr = [ 1, 1, '1', '1'];function uniqueArr(oldArr) &#123; // 新的数组 用来存放去重后的值 var newArr = []; for (var i = 0; i &lt; oldArr.length ;i++) &#123; for (var j = 0 ; j &lt; newArr.length; j++) // 如果两数相等 则跳出第二个循环 if (oldArr[i] === newArr[j]) break; // 一轮循环结束还没跳出循环 则表示此数未再新数组里出现 则加入新数组 if (j == newArr.length) newArr.push(oldArr[i]); &#125; return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1' ] 方法二： 先将数组排序，再相邻的进行比较，不同的存入新数组。（这个方法有缺陷，因为sort是按照字符编码的顺序进行排序，所以要先将数组的元素转换为字符串，来进行比较，下面的数组的这种情况就不能完美的去重。 个人认为sort方法是通过交换实现的排序，在数据量比较小的时候用的是冒泡排序，数据量比较大时用的是快速排序）1234567891011var arr = [ 1, 1, '1', '1', 1];function uniqueArr(oldArr) &#123; oldArr = oldArr.sort(); var newArr = []; for (var i = 0 ; i &lt; oldArr.length ; i++) &#123; if(oldArr[i] !== newArr[newArr.length-1]) newArr.push(oldArr[i]); &#125; return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1', 1 ] 方法三： 利用数组的indexOf下标属性来简化循环 (includes 也是一样的)12345678910var arr = [ 1, 1, '1', '1', 1];function uniqueArr(oldArr) &#123; var newArr = []; for (var i = 0 ; i &lt; oldArr.length ; i++) // 利用indexof 判断某个值是否在新的数组里面 if(newArr.indexOf(oldArr[i]) === -1) newArr.push(oldArr[i]); return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1' ] 方法四： 利用ES6的 filter 方法 加上indexOf 返回第一个item出现的位置123456789var arr = [ 1, 1, '1', '1', 1, '2'];function uniqueArr(oldArr) &#123; var newArr = oldArr.filter(function(item, index, oldArr)&#123; // indexOf 返回第一个item出现的位置 return oldArr.indexOf(item) === index; &#125;) return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '1', '2' ] 方法五： 利用对象属性存在的特性，如果没有该属性则存入新数组 (这里的 1 和 ‘1’ 在用obj[]添加属性时，会被自动换成 1 然后加入进obj)1234567891011121314var arr = [ 1, 1, '1', '1', 1, '2'];function uniqueArr(oldArr) &#123; var newArr = []; var obj = &#123;&#125;; for(var i=0; i&lt;oldArr.length; i++)&#123; if( !obj[oldArr[i]] )&#123; // 属性不存在 则加入新数组 并将该属性变为 1 obj[oldArr[i]] = 1; newArr.push(oldArr[i]); &#125; &#125; return newArr;&#125;console.log(uniqueArr(arr)); // [ 1, '2' ] 方法六：利用ES6的 set 对象自动去重12345var arr = [ 1, 1, '1', '1', 1];function uniqueArr(arr) &#123; return Array.from(new Set(arr)); // 利用Array.from 将Set结构转换为数组&#125;console.log(uniqueArr(arr)); // [ 1, '1' ] Object键值对去重123456789var arr = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;];function uniqueArr(oldArr) &#123; var obj = &#123;&#125;; return oldArr.filter(function(item, index, oldArr)&#123; // 判断 obj 对象是否存在item这个属性 存在的话返回fasle 不存在的话 向Obj中添加该属性 return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;console.log(uniqueArr(arr)); // [&#123;value: 1&#125;, &#123;value: 2&#125;]]]></content>
      <tags>
        <tag>🌝</tag>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 操作常用命令]]></title>
    <url>%2F2018%2F04%2F21%2FgitCommand%2F</url>
    <content type="text"><![CDATA[git所有的命令都是以git开头 后面为所要做的操作 再后面即为参数 初始化 git init 初始化后会生成.git文件 git clone URL 将URL地址下的资源clone到本地 git add . 将当前目录下面的文件提交到暂存区 git commit -m ‘你所做的修改，利于以后维护和回退’ 会得到一个指针 git push origin master 上传代码到github master分支 git branch 查看所有分支 git branch hexo 新建名为hexo的分支 git checkout hexo 切换到hexo分支 git merge 合并指定分支到当前分支 ##git合并分支&nbsp;git支持很多种工作流程，在进行合作开发时一般是这样，远程创建一个主分支，本地每人创建功能分支，日常工作流程如下： 去自己的工作分支 git checkout work 工作…. 提交工作分支的修改 git commit -a 4.回到主分支 git checkout master 5.获取远程最新的修改，此时不会产生冲突 git pull 6.回到工作分支 git checkout work 7.用rebase合并主干的修改，如果有冲突在此时解决 git rebase master 8.回到主分支 git checkout master 9.合并工作分支的修改，此时不会产生冲突。 git merge work 10.提交到远程主干 git push origin master 这样做的好处是，远程主干上的历史永远是线性的。每个人在本地分支解决冲突，不会在主干上产生冲突. 可以在一条分支上一起开发，你有变更的时候，在提交前，使用 git stash 这样将本地的修改全部缓存在一个堆栈中了，然后把别人的修改同步过来 git pull –rebase 下一步是将自己的变更恢复到最新的节点上 git stash pop 然后再使用git commit提交，这样就会让一个分支的版本按顺序继续发展]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己搭建博客]]></title>
    <url>%2F2018%2F04%2F19%2Fhexo%2F</url>
    <content type="text"><![CDATA[Hexo 是开源的npm的博客包使用markdown语法写博客 结合github page 服务，有一个免费的开源博客 git配置过程 全局配置 username email ssh 在git bash中执行代码： 1. git config global user.name &quot;gitname&quot; 2.git config global user.email &quot;email&quot; 3.ssh-keygen -t rsa -C &quot;git@email&quot; 一路回车 找到.ssh文件夹 打开id_rsa.pub复制内容 4.到github上 setting 中ssh key添加 title为空 粘贴ssh至内容中 验证一下是否成功 1.在hexo目录下将 https://github.com/HeiLiu/HeiLiu.github.io.git hexo init 初始化博客 执行一下初始化命令系统会去github clone一个博客来到本地 ./node_modules是以来文件夹，npm包 项目所有依赖都在这里。3.博客存放地址 source/_post/**.md4.markdown 语法 更简捷的写html5.theme主题文件夹 hexo clean 清空生成的站点博客文件 hexo generate 博客的产生 hexo generate 将markdown语法编译成public/*.html hexo server 打开本地服务器 hexo deploy 将本地生成的public文件内容发布到github]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想把我唱给你听]]></title>
    <url>%2F2018%2F04%2F19%2Fheihei%2F</url>
    <content type="text"><![CDATA[想把我唱给你听 趁年轻尽情地爱吧最最亲爱的人啊 路途遥远我们在一起吧12345678910111213141516171819202122232425262728293031323334353637383940414243想把我唱给你听趁现在`年少如花`花儿尽情地开吧装点你的岁月我的枝桠谁能够代替你呢趁年轻尽情的爱吧最最亲爱的人啊路途遥远我们在一起吧我把我唱给你听把你纯真无邪的笑容给我吧我们应该有快乐的幸福的晴朗的时光我把我唱给你听用我炙热的感情感动你好吗岁月是值得怀念的留念的害羞的红色脸庞谁能够代替你呢趁年轻尽情的爱吧最最亲爱的人啊路途遥远我们在一起吧我们应该有快乐的幸福的晴朗的时光]]></content>
      <categories>
        <category>有感</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
