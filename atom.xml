<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeiLiu</title>
  
  <subtitle>有一句Hello World想要对你说</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heiliu.github.io/"/>
  <updated>2019-11-07T09:23:59.652Z</updated>
  <id>https://heiliu.github.io/</id>
  
  <author>
    <name>青衣诶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>九、十月复盘</title>
    <link href="https://heiliu.github.io/2019/11/06/20191106/"/>
    <id>https://heiliu.github.io/2019/11/06/20191106/</id>
    <published>2019-11-06T14:50:00.000Z</published>
    <updated>2019-11-07T09:23:59.652Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="对不住您嘞，密码不太对，再瞅瞅？" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。"> <div class="hbe-input-container"> <input type="password" id="hbePass" placeholder="加密文章，可能是个人情感宣泄或者生活记录。" /> <label>加密文章，可能是个人情感宣泄或者生活记录。</label> <div class="bottom-line"></div> </div> <script id="hbeData" type="hbeData" data-hmacdigest="5a27385c22e332dbe768bf82538eb2c8b03315a0a302dba98851d8f86bc1498f">91868fe92bac4993c4028cc40da992adc432c7c6933ab1489a8014e35f893b4601f85fc6aa3c85c751ffbc8067b3cf0307bb0922656e3b19b40a7c667d5faebba36c11b03f916c60fab89b6a195487751951cf6632efa3245c958cb8a6fff60f2a3db1eb6bf3a2da2e3461087451d39cc468d4b625460e7296b74dd5c8520c3a1e8632bbda0dd3d331d9445ac2863f78c47d91fd643a353d22157ff9c2557eaad2896bf3ec18f9c05f0bdb8dc3240f1c0aac061108a9f0ccf21a4d06f6a167e04966a22b3afa45a021d90e17015e03d5a50f2742725709975584a06d93624803459db411a30c760216f3f327e863772ca03a5c5c2c09ec386120914b7d7cc233e061bba8b1f56c043935af962efdcdacdf04018547890d949a8d50fcdec8b5c18f5f3300428a2ccfb9456752d43910943c9e136136842459f422528027eee61a45f4ddb801821628c5cda144e509646a4c1c53e0d5c90d789ad2c02ae38d7651300fce9dff64564cdfe8f750aed619cd66946e0ca82860e8d2ef75d473ae6c97fcb8061a8bc97118c2b530fdaf507add968bf1b0646fbdc40ba68240adfcef0213af3580a1ddc3cf41d2ca7198bf8ed60ff42cd26f95979162bdae16f125adc093e0fedd0bf63542342b1eac0a80febc0887ff7c2a2f5960c04947b7e102db31b41584caa2d2001703e554867fc6f539c31399d4e532a17209a156a7827583b599ef7297eb9879090d292a40d57d5bc14ec45fddc435b21218fdb2d7266b4e7d5bb56a8073c7c29e68a73158d76d223a00efdd42e82500dbe4a0a52b77da377b39606a9e52e575053eba0d30457cffbdaa03acb72d65b2c5b95c54337a33ddb5a35b4542b8612303a033a7eb49104751382dbb8674a3d7a9a6bbf44630d78632df2f1cab561c019b2bc3d6e88b7464e8fea01926160e85b58a3a5c99784064b733c6fb408f54af00ab90c99dbaf3fee756e21d882580d604ba5d8122764c004a8425b4b7b53028f164a1c9a23c2eafc8ee1427c38db4ef520edee57042ddc4fd7b891f1e5d155b080c4c8cacff929f39c73a1b6ba71f8a03d0ff2c6f30c5a7558e0769d63e62c2444edc5c25452ece9b4376182ab7dd6144dafc45e19859123371133b8de2a1980cb29bb393b852a6e0d4ab54bec7ea2cb14752c24f8d1b56bd9a5bd0699e75a94327cb6842308cef801c4238cafc6fe6e1183bc18434aac14cf7e560b6a345acbe3cb0f10399696366295ea999141b340489d6e8b3feef541e8534c6611afad90523db144acac3aab0bde873b04a8c8e6bf255d526af9e9c1833f9eb397f0406ac2725db327794ce14eb6a8ed51bfedb4ddce60583e3ebf04a4afd123d161c43254b0a843ac79351cbe66c93db8037fa08d0ec351af5a88a68f7c8e6c70c9220d0c666f6f11b2d4775597d7f4e3796284b02f05b08dec244f188d0f254c5efed23542c46eeba9bce6db95ce3163e464c371952646884d5aaa480988a735f520caa6f7d9b8a8bf56132f7587f7021582dbeba1febc79c19b41d90e92c5199e5ad50ce2596968590bd00fa17ec37d5273c56d927e0d7e34b65a37179046df075a56177aeaffa1bd1f46b2a2cb912ecb03568928d889fd3a9c1124ec497bcf4ed2bb2324c79c1102734c865ded8d2e5af3d43a162a8fbd331dfb1cdd8b21bd6477d1ed9d70afe4131cf1919295830bacfb6a6ac329be07644d6543f8f0279671b4b80d70541e1fa3d26a0b9c120c4599ba14d083c4f08891a8672f343a9b53cc432e3f6ed81d9cba6b2b87176b4b310371ead4dd7b70a713de14210865c3341376ea98f95614465f40182bd52db24cd7815ddbd2a306d384c3b43371008b09f85de698036928375bdc0b2057354057f7a7e0309bdef14ac6c7fb830bb06d4824a311d0b3ca7231a66f8c6ec0b1c3898ee61a224f2bd2b6b77598abff86acf5d74c3d586b0aca06174ad70db302f0569fefb80b5e2be21a8c5583d8b2b688148ed22d1962756d791cc25f39fbde2f2fe8bb9713babce5e0d7544eb0ac73577f99e17100adfeb0d12607a7b688b6ed3921329b2d81d72b57668079f81f78421ff9d1d3cc1acbc772598a369f40848b723cd57b720cc3d88f363efa61a900129d2d03503f350b2453a113da7f90c6ab59c891e696816733da84857aeaef98cb631967f086cb9161ce6b4a647ac96dc3811aa83983cdec275dff9495d865f84b1c3f15c8767044727f32fe61a095051dc066b86e30fc683ba99eb6f6ee735bbe59c025b592106290d8a65c26cc671cab7c825c26360a18fc778b780b8d9ba4e7c0cb57cbf2724a312bd5575609dac2bcf59ebb88fadd0366c73535fb434eacb19aa4d99595b20803e269f20277d67f993b7e41bff33b639bfbb79823e6c9f520073fe0515f10e0a3dfd496a87c0b42d69da2367cee0adca5c6e73e74eb31aa477e64b90ba1a46afb197a1613ddeb4e36d995748b67aa83ef6917a55f9d4c2b7528b58c41604fc8d398a1df0d92f9de892d75c04e810fd496f1c924fe29921095b6957916209709a7b1a62ca1d6d8f533562f8609b34ecc695334b629c4db4ed38359d5c9407015664b11f8f5c95317bc53d33fa45c03a0a90cfae82913476169bddfa4ae3d7490c0617dd35515785c88c2c94048dc8b31f9bb26d9c600f8a55a2f30f86bd0efa20f1dd5358d7bf03b8724a803b01acc1427568eed0a334e0438ed9e012af0bdc0e1635300e804b7b1ceb06cbc73bb105ffd0ab2d19badff5757bb4b2638ba3ef907cfb8111e967095661ca6a6850dcfbd884d97a267d22ea82dc1ee4d85edc26f88b3950785dd8295f1389073156929d4058bd5abfaf123ad46e9d63ff7d2026ed8fc241f00fc3c644d6df233bb9684533def99db872e22ba89877c148c3d87ac283fb61f886f7b008f1b4a485dc480d8bb2cb75e7c1c25e758a9f1db0913a329b02d98322c9b0d97e5f74f1dd2f1f12f1e1c6f514e1a1a0a4ccd3ca8d0b2c5b3dd90f261966e1c473c7ddedfc5ead1ddd9035775cfa58ba462de1f8faec7c3602013c987c55837a6f185fff97e16773122ab347f1803b1dc5bd7fa8d8ccfad9d424de135bdcd27b076234e74c84f9c26ffa94103ba9cd11b40fd6edb9910bfd59dbdddefc48e548a0fba6c1e12fc45fe4f7a1a883c4ebd8989daecffd72a77c4330293825ab1860a596c62bb47aa56675921256f235449908e92715f5fa514276a545d2c936136c68d00a1cf6d3e2fb26024fb4594064394dc55a4649f1eac7be4c12cf006f181fec510df656d21bcbff77a1ac8805b2294b706b852156a33b0347d212361443c4be882903232dc2e8dd8e6e12c0566867d60a21f8565fddccd041d2a2db79dd3ab7cf1cf1e697a150f50ec5582875649483eb04843ada70cde2831a6c4a8442f82cf6f2655b664162d8c51dbc90e4c718743ccf2687afa45a2846abcd6894a46608f80b7f579bad3a8a323464a940bb805ad25808b02d633234774d29729f28cc4e1942e68bead7219996e8e5083799a51f99f56c93b50c79c018ffcb510c828d6d72d4802381b7551fd0804de650030faab57f80a3b302047c3b2d733d4c4af360b5897221b7efe68085c1bdf43a907b3c18480d5f1c640670bd249443189921db62a80a7cad011fd5309e21ae1709911648deb6292ed257cbfac4f77853837c570fbd48663644221aba1c6c65861d9de25a6f1d2e641030b2a7f04ffdf627cf1653b258d2a75499b75ec523060a50fbb26546eff78c3ed21d62d8f9465609de9d36d38975db0234c028f356430671e39da4fac2ba33c6660b94acb5dd1a741b00f4f818d02b9581ee6212a51a38bcdab6f99d10cbb263ae06cd50dc24c74ab77380bddd883ff2c7d865f12186972d443e2eda28ffa049ab9fa72bea9d5abe5560338db6cab80797ef3f07220adf46dc78a7c7ce02e019cfaa2e2d7a5942f3369cc4524479b680719784d629114bad40f46644e3eef0d87e8abb5ddd8a70cfd0e20b0035893d013ecdcbb80678e8192267e21d7fda9e643ea1d7e7ad73b47db9325c0aa60deddf1c345eab6d3820471a9e9c8c149659755ae684bf815eb03880342a1b15a673a1ac71632389d45c6cf4daade2a256e19f1cf44c651a91fa14ec73d192a7389a75deab97d2d8b1b530c945e9930f75b6a0693cdd1af5bd7ec1adfd96f84130565c880fb85c6fc1387cece9b4289b7f922e8416100163f3c8f66616942cbcd3e9d049bedba7b0f9c47c22e6db4360616c1450443ad9338295b62efb9c805debc24f5616e829f4da2446f95e2b9f0ac9bf67b372fad9eb2f0ebe25157634e46bc7e575be334bd58e028cf4b7eb67a5c18854dc254d6794b054002c9b7a244b9b257139e2684d799a83edd2d4c3c6b845314b5aee462b79aae997f410efaf3410a64e0c0a443ae563d22ed186bd022f6ba7cf834c5a125f6c08fe23d25ec5874f48ad12dfd54864ce588aceb8b7edaaf22e1c765dead6cbd433dc5af83c6b2f1f65831cec119f059cacd7b952fcabc2766910e4e0a805ed66cdab926c1d8ef50ebb05b072f091bffc8b2937d6031de4f6ac1c96251aa2e2a79a97a57aae3ea7e1c9b5541606a5275f4d96716c4e8dfa47260f25dce6e572743c220e8a3d738cebe010ae91f64fdf20450f476708f290368915f8470681d8a10539262b6628c291151bc67d8b468c07822a98d1c47ffd74485109b180fa2d0671c9a91e71d6504da78e05a5b0ded9d20ef5e976f663f2a2c1c69f4e931489b07b17926ada7fe429f56892bc8b8c25bea63f54d3fd3f991cc18ad731899db7382305f6b83171e2d75d9b4558aefe71a31c066827e7bf58aee267fbee6c20eeb53670a5d29a23f5eb9d6daa08d7330298d85a9995fb3a352151fc8924324a10a23fa24b66c79cd93da73e46df10eb2e03296264cc98baab247177d45b383df62bf31125e4ff98714150606922378eba00451b919d12e4795413ff14d013488940fc9a503f67eec1b7a3c8e2d83a902df4c49790139806ad841e62e9b3daae9cd448dbe0219d106d4e2891b63bf091e8987a6d640dee42faafe6e672b66a5bcfae079bca416ec33db9ac6b4d55034776be90de64eb0c727050134b78c3749222e3bcc4fcda97c078775dd2c3f1de05406a872d08b2e2450e1922a12e36750d53d6ef365a8e316289a7badcecaa0ca781da4a71179656ef1055b88ba4e053f3243e7c8599c8a02ef7fbcf0ff5b603db7c916783ab061ce4a2603400915fd8f032d7e78a89640374979ff06714e90e30557f4d002eba9c9b8456c01e0b9d865142bf5714ca7dfa22ac6974722b4854880b90f27a01f5fa63752cf4eb0e38ea584a9756b786913ec2e0d2626a51257507e254425efc28b99d1805b9528ef70848bf37d58b18243b19a9cb9e846b5ed08be171ef2ece902977e8236149f725003f69eb1772f9385346f5f4a90f47c2c74d7b928700fc35065b624000b4d4dd8121e0e851433198cca9173f65892f06fa7c430039f8f561416d04ca35cb7cb37d42c5488048075ad45a15ca81f51d5b8974658fb2c316f3b48ccae77d5de98ee2b10e012d944825c302130a0d46158ffbe768d7dd5ca1e9b05a758dc58f88a00e4d1f7f7dfbbb2ec3436d00dcc8cf8b7ca9be6e463dce35f09df01434453bf80a4bfb0b54653369daa8ee8b6404bbef118dc28374ef88ffedceb7f0403692f730c73b376b5e5304521a63b7f7b634e8860e5326425f18a463ea5500d136693a62b6d202689cf7d58ad07f4be53bd80f7d2bcaac9db5c7549354c0b545bcc166d06a2c474dc852c00622276557295e28eb802b38682327243082e6a213018c5b5728dd03145b298946ad7dca602d498e0810cd0a789812276215e1e3d0452c7696a85dda8aba1eb91cd4295f91867a398bd2341b174b3f8310ab3a9d1aa00d2a2375c15e58d952605d7f27cae077f6539993c09d3f0708598a77379f6a4da13bb928dd53f0dafcd5c2fd2adbc84844f06b52325dae7fedc45d7872ea6c1fede52eb38dd7bbadbf8068f299f53c411d76860739cf23ace94fade02a95ab7558fd885b05b3cff1c64db350119fc24bc09a4e1551dcaafde06d96aa396cce244fd769edd8f91426ea5250318aca7d7a6f9ad7dc4d43a7394f236b8c200a9e133fa04eb34797b5d213efbd25b307982126aa5b35b1b61ab1fa831e3bb38e9db15f71a48046bb9b7325aedd8386f40fb96ce73cb48727c3378bffe1baa3e17550607c9dbd654d4c743fb11a72438506b33a36d7ef9e21902d60182f9cf6213f0eedd13e0fbe961ef7192b5753b2b9378ed6456e49a979fdc911fee0a410bed8f9cf706af309e06c5e0c6f89a39f393929fbe8c1dc9dd34158f8c5435b73ec79c5ead6de05e93ef586ddcec15d04e34b6feaaac3a5787c418745111e54a1afaf8fb9ceaf7c00390edce1c180f63d346982d43be35e8b5be553c815368793409c2140cdcfb70cfa4f83b9a09e8cbd6c918c26c8d080f2041d75ae172138f0f43844b25e68f663e32bceecf856aed744c6406ffa31aa2753ce81e789c9ad020be672dee6fd6d45c791f494925d56db59b81d4a29cd0768758c36461a4e5eb8a129256d8c7a317e02c1dfb81fc69d5056834d3023f38bc29ce17fa1dd48e9f2c4b1cc669b58c24bc4dbf207bddb8254c604d0473969b5e7534dd4417ff262499e21a3842433e138d23ce05c8b611d0c1f2a6822d33dae9c1c524cd63f8c85403c07790b2fdb1a9cd56e2f3221d8365a256fed93c013d9271f3a1003127dad7750c3f6dd99ec96c09cc2d62f5068fda27ac203553cd340aa54c8b96c28c5a7e9404f243fb561d7e33c84de3db90a5257b6478247944f2daa2307c2ee218472dd4c6ff8d53cebab11ff603e540f9bfa4035e5642a32b7f4710e81cbc59d55d5d264bb5d80d386c63156c5763219d4c611eaf825184aaf66f3b90b2248c12b5b0414c6827da495fd30ff3c0985835a16ae6b6b47ee4ede9e887c1fef9384bbdea6bf332e1d86d30fcf11b5b7451dcb7e173c8dae5ddf10cc09e1f48aeb1382831e076e5b8af8e6b9d2bf11510f2448ee530880729c0cba84c50cc570464ab6aaae33970f8782a5fa1f818bd3d5dc78c25f703b598d812a4755c5754bd18bfa5bfcbc1b96bb76460e5838fafd2e25cef2d66feeea09e03b067c4a5725a7b1ac783ca4056e01ec9b16944ca5e5836c38fce2c54e288d3a6edce12633a9def40e337ecfa0cf8068f23018863102e6be6f1ca99458eef7e404a0e401cc38004aab5bcaa0c0aff2ce8dfcd0df581ceaf45cf46a40ffeeda03949c55615d3d9359a98a2318946fc2dc0635ce730f45ac59c489b30e14633e7d04563d0cfcb7e052127f1092f190f970d73c07a93c1e9bd636ee23db6e5f2ba1ea72259ce70644a7347c929c2f9e909d9ba42f44dddc6e1364e65d9e616b9a9bbb747f8d7afe78a38fe16ba4e00da2c864f502d3cbe771ac7097636d80c74a50a3c00258d1b11c4731889dca2ca743dbff417592ec87e6b36186e93b3f5eba869416c028200bae6b105bede4510cb0b2071a384828b977e3c9d7dd1da115b3c4fa0cb22f38867b1c450117dade4430fb943c183a7ff62875a12ac96a0275991fbb2a439e3a48e346e9443e27cc0f93eb39a72b00663ea54112b2b3c8ed789c48f4019bd8c9f3004d6923ceba877a50b9c0053e2ecf888ee596d763a2b7e0025081ad28ff0e206fdda15dcd1bf03f28b785d003e41f6fe09317c6359da3cf7e74e411a9fc90d6fb0daac30253213690efb2f0a2094011f353babba7d301b3a3dc1b5e50c70dd392be633c304e1b1a86fee71416cbcabd67a4266748f39e5f393280d4ced1113e912a829f7968a07d2c517ac00b04fb34590ea72383b358dc6c14d955dab9f4028815882b72d27c3d93cdfd7ebca598070ef9e4b7fb74dc37c5bc510d303cb97c0cd68ad4da9f81970ff5e8cb0a42aea0ac0024aab46b42112298bb307603686a7981a23afecd1aa1ca70dd2358f4f914e02ef79f77740f5e7d45af9162ae545eb153bc32c5d916d851393b7cd9f1e6e71fd347b2b72a5fcb60a3ea8927a72cdbe3fc29be63e23b6ab19e6800191682621ae3147b49500afb149760d54cd2c3cd95ee0e9c217c5c60cec89ef7adec5560b905badbe8cde57afd90cdb64ade3a65c06e589f4c7075c8f517cea4cb064758292286ef8bc506c658fe726688bc10f5979bd8b85534d4f281ff23e6bca75da2a86fd81a44b69e3fdef7c38e0c3908f57a8201e753ecd0b48ca740bd09e436b1607db1105dcfd376963bde52e1598c355f0eb493d9e88aa7a406c087d361b6c873d62a865b72a193312e1608e65e323be31c46fd61253ef5f40f4c8a09c49f17067efd391daffb97cbcf57b904bee5534eb6a819d0693099b30dd05e17788354f2a39b51c0b03159155b8c3334579ad5f649c02dfb760d79ef72c4e83d7863cb430da1ba8635226d65a44cdd68aacdc1745d61ec777532e07f77b0231496665f6dcc2011191f8693cac041eb24f1931cb062ba143435c72bde41f0d158d978496f16c270a610888bfae979d4decae02881df2e470258c6f2001fb5cbf6ab85f396a74f88961e37d4c9442f7fe1b077abc89aea90d26a27ba1cf2e7d587f25c38b2b390de15e673bebc74a91eb5ba8af6632e2ba9b2f3d5380a773cf755fa3ad5105c252c2c9de4e531f940a5665b27e8b3538c2900af830abceeb3d66b0b8cd92ae8c04e1173b9dd2039b9530f4e00234327bc5186098928f28eddad56e6d68df81973765408ea704f144f50c2b73a1438cba59a691dbe5c1286a98ce949e452f821f4361723c8cae7cfede86e7985b76658eee9b289194c421782554afaf9</script> </div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      原始文字是人类用来纪录特定事物、简化图像而成的书写符号。文字在发展早期都是图画形式的，有些是以形表意，有些是以形表音，其中有表意文字，与语音无甚关系，中国文字便是从此渐次演变而成。有些中文字可以从表面、部首、字旁看到一些联系旁通的字义。而这些特色是拼音文字所没有的。其实这是一篇加密文章，需要密码查看。
    
    </summary>
    
      <category term="有感" scheme="https://heiliu.github.io/categories/%E6%9C%89%E6%84%9F/"/>
    
    
      <category term="生活" scheme="https://heiliu.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="有感" scheme="https://heiliu.github.io/tags/%E6%9C%89%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Prettier 相关</title>
    <link href="https://heiliu.github.io/2019/11/06/prettier/"/>
    <id>https://heiliu.github.io/2019/11/06/prettier/</id>
    <published>2019-11-06T11:08:00.000Z</published>
    <updated>2019-11-06T11:11:38.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prettier-介绍"><a href="#Prettier-介绍" class="headerlink" title="Prettier 介绍"></a>Prettier 介绍</h2><h2 id="Prettier-配置"><a href="#Prettier-配置" class="headerlink" title="Prettier 配置"></a>Prettier 配置</h2><h2 id="Prettier-NPM-包"><a href="#Prettier-NPM-包" class="headerlink" title="Prettier NPM 包"></a>Prettier NPM 包</h2><p>yarn prettier:check;</p><h2 id="Prettier-插件"><a href="#Prettier-插件" class="headerlink" title="Prettier 插件"></a>Prettier 插件</h2><!-- 未完待续 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Prettier-介绍&quot;&gt;&lt;a href=&quot;#Prettier-介绍&quot; class=&quot;headerlink&quot; title=&quot;Prettier 介绍&quot;&gt;&lt;/a&gt;Prettier 介绍&lt;/h2&gt;&lt;h2 id=&quot;Prettier-配置&quot;&gt;&lt;a href=&quot;#Pretti
      
    
    </summary>
    
      <category term="Skill" scheme="https://heiliu.github.io/categories/Skill/"/>
    
    
      <category term="Prettier" scheme="https://heiliu.github.io/tags/Prettier/"/>
    
  </entry>
  
  <entry>
    <title>React中的Refs</title>
    <link href="https://heiliu.github.io/2019/10/26/reactRef/"/>
    <id>https://heiliu.github.io/2019/10/26/reactRef/</id>
    <published>2019-10-26T14:33:00.000Z</published>
    <updated>2019-11-07T10:25:50.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><strong>官方说明</strong>： <code>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素</code>。</p><p>在React开发中、想要操作元素的状态一般是修改State、或者是修改传入的props。但是有时候一些效果不能通过如此操作实现，例如开发中常常碰到的： </p><ul><li>输入框的焦点获取、比如打开登录界面登录框自动获取焦点 </li><li>动态的根据一个元素的大小/距离 计算另外一个元素的大小 </li></ul><h2 id="使用-Ref"><a href="#使用-Ref" class="headerlink" title="使用 Ref"></a>使用 Ref</h2><p>目前的React版本（16.11.0）中 <code>Refs</code> 的用法如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React form <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 传入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>对于节点的访问:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="keyword">this</span>.myRef.current;</span><br></pre></td></tr></table></figure></p><p>说明： </p><ul><li>1.通过调用 React.createRef 创建了一个 React ref 并将其赋值给 this.myRef 变量。 </li><li><ol start="2"><li>指定 ref 为 JSX 属性，将this.myRef 传入; ref 和 key 一样不属于 props属性，二者都会被 React 特殊处理和维护。</li></ol></li><li><ol start="3"><li>ref 挂载以后，ref.current 指向 ref 所在节点</li></ol></li></ul><p>如果之前用过 React，你可能了解之前的 ref 可以通过 this.refs.inputRef 来访问 DOM 节点、如下所示，这个 ref 是字符串类型的，在使用上来说似乎更加方便。现在官方版本不建议再使用它，因为 string 类型的 refs 存在问题。它属于<code>过时</code> API 并可能会在未来的版本被移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React form <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.inputRef.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 还能用 但不建议</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"inputRef"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Ref的值"><a href="#Ref的值" class="headerlink" title="Ref的值"></a>Ref的值</h2><p>官方文档中有说明，ref 的值根据节点的类型不同而有所不同：</p><ul><li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。可以访问元素的宽高等属性、input框还可以调用focus方法实现自动聚焦</li><li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。即可以通过 current <code>调用组件中的方法</code></li></ul><p>不能在函数组件上使用 ref 属性，因为他们没有实例。</p><h2 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h2><p>更加精细的控制 refs 的传递, 可以达到类似 props 的传递效果，在需要的地方传入inputRef </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方 Demo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;CustomTextInput</span></span><br><span class="line"><span class="regexp">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>官方说明</strong>： </p><p>如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p><h2 id="Refs-转发"><a href="#Refs-转发" class="headerlink" title="Refs 转发"></a>Refs 转发</h2><!-- TODO --><p><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Refs&quot;&gt;&lt;a href=&quot;#Refs&quot; class=&quot;headerlink&quot; title=&quot;Refs&quot;&gt;&lt;/a&gt;Refs&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;官方说明&lt;/strong&gt;： &lt;code&gt;Refs 提供了一种方式，允许我们访问 DOM 节点或在 rend
      
    
    </summary>
    
      <category term="前端" scheme="https://heiliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="https://heiliu.github.io/categories/%E5%89%8D%E7%AB%AF/React/"/>
    
    
      <category term="React" scheme="https://heiliu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>记一个伪元素的骚操作</title>
    <link href="https://heiliu.github.io/2019/10/25/beforeAfter/"/>
    <id>https://heiliu.github.io/2019/10/25/beforeAfter/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2019-11-06T10:22:27.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用伪元素实现气泡框"><a href="#用伪元素实现气泡框" class="headerlink" title="用伪元素实现气泡框"></a>用伪元素实现气泡框</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;在项目开发中本来自己负责的基础组件库里面的 <code>Tooltip</code> 组件没有达到预期的效果(有八阿哥)…<br>  &nbsp;&nbsp;&nbsp;&nbsp;后来想到其实可以用伪元素实现一个类似的气泡弹窗，但是又想到一个问题：我每个元素的气泡内容不一样这尼玛怎么填进去呢？<br>  &nbsp;&nbsp;&nbsp;&nbsp;于是乎，查文档、还真在文档里让我发现了一点有用的东西，通过 <code>attr()</code> CSS表达式和一个<code>自定义数据属性</code> data-descr 创建一个纯CSS, 内容提示气泡如下：  </p>  <iframe src="https://codesandbox.io/embed/crazy-chatterjee-9h066?fontsize=14" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="crazy-chatterjee-9h066" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"><a href="https://codesandbox.io/s/crazy-chatterjee-9h066?fontsize=14" target="_blank" rel="noopener">https://codesandbox.io/s/crazy-chatterjee-9h066?fontsize=14</a></iframe><p>相关属性： 自定义属性 data-desrc 表达式 attr()  </p><p>兼容性： 还不错哦！！</p><h2 id="各种链接如下："><a href="#各种链接如下：" class="headerlink" title="各种链接如下："></a>各种链接如下：</h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after" target="_blank" rel="noopener"> data-descr_Demo链接</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/attr" target="_blank" rel="noopener">attr() 具体文档</a></p></li><li><p><a href="https://caniuse.com/#search=attr(" target="_blank" rel="noopener">canIUse</a>) </p></li><li><a href="https://codesandbox.io/s/crazy-chatterjee-9h066?fontsize=14" target="_blank" rel="noopener">Demo地址</a></li></ul><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>伪元素实现气泡提示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltip"</span> <span class="attr">data-descr</span>=<span class="string">"伪元素"</span>&gt;</span>伪元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltip"</span> <span class="attr">data-descr</span>=<span class="string">"实现"</span>&gt;</span>实现<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltip"</span> <span class="attr">data-descr</span>=<span class="string">"气泡提示"</span>&gt;</span>气泡提示<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tooltip</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tooltip</span><span class="selector-attr">[data-descr]</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-descr);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#202020</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tooltip</span><span class="selector-attr">[data-descr]</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#202020</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border-right-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: transparent;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用伪元素实现气泡框&quot;&gt;&lt;a href=&quot;#用伪元素实现气泡框&quot; class=&quot;headerlink&quot; title=&quot;用伪元素实现气泡框&quot;&gt;&lt;/a&gt;用伪元素实现气泡框&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Skill" scheme="https://heiliu.github.io/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>单行文本换行与多行文本换行</title>
    <link href="https://heiliu.github.io/2019/10/23/text-overflow/"/>
    <id>https://heiliu.github.io/2019/10/23/text-overflow/</id>
    <published>2019-10-23T08:23:00.000Z</published>
    <updated>2019-10-23T08:24:05.434Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/entry/5aa1f4916fb9a028b92cbdcc" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/5aa1f4916fb9a028b92cbdcc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React Poratls --传送门</title>
    <link href="https://heiliu.github.io/2019/10/22/react_Portal/"/>
    <id>https://heiliu.github.io/2019/10/22/react_Portal/</id>
    <published>2019-10-22T09:50:00.000Z</published>
    <updated>2019-11-06T10:21:11.056Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中常常会需要对话框、下拉列表、悬浮窗等交互的组件，当在父组件中使用一个下拉列表的时候，父组件的大小是固定的、同时还有一些overflow: hidden;子组件想要完全展示就变得比较困难，或者不能完全展示、或者阴影被父组件overflow给hidden掉了，同时在用overflow去清除浮动的影响的时候也要考虑到副作用，当元素比较多或者内容比较大的时候会不会被截断的问题。这个当想让子元素的层级最高而且不用被父元素给截断的时候就需要一个容器或者元素能够脱离父组件，至少从视觉上就得脱离父组件的影响。  </p><p>Portals 是 react 16 官方提供的解决方案， 使得组件可以脱离父组件从而挂载在页面的任何地方。</p><p>在做组件层级的时候 应用的skill<br><a href="https://xuzpeng.github.io/2019/05/04/React%E4%BC%A0%E9%80%81%E9%97%A8-Portal/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中常常会需要对话框、下拉列表、悬浮窗等交互的组件，当在父组件中使用一个下拉列表的时候，父组件的大小是固定的、同时还有一些overflow: hidden;子组件想要完全展示就变得比较困难，或者不能完全展示、或者阴影被父组件overflow给hidden掉了，同时在用o
      
    
    </summary>
    
    
      <category term="前端" scheme="https://heiliu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="https://heiliu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>在 React 中使用 mobx 进行状态管理</title>
    <link href="https://heiliu.github.io/2019/10/14/mobx-react/"/>
    <id>https://heiliu.github.io/2019/10/14/mobx-react/</id>
    <published>2019-10-13T16:00:00.000Z</published>
    <updated>2019-11-06T10:21:25.460Z</updated>
    
    <content type="html"><![CDATA[<p>observable<br>inject<br>computed<br>action </p><p>RunInAction<br>Reaction </p><p>调试</p><p>toJs 需要引入 =&gt; 不如直接 JSON.stringify()方便</p><p>不用使用数组索引或者任何将来可能会改变的值作为 key 。如果需要的话为你的对象生成 ids。</p><p><a href="https://cn.mobx.js.org/best/react-performance.html" target="_blank" rel="noopener">参考技巧</a></p><!-- 中文排序 --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">name</span>:<span class="string">'武汉'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'北京'</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">'上海'</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">'天津'</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> resultArray = array.sort(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compareFunction</span>(<span class="params">param1, param2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param1.name.localeCompare(param2.name,<span class="string">"zh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(resultArray);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;observable&lt;br&gt;inject&lt;br&gt;computed&lt;br&gt;action &lt;/p&gt;
&lt;p&gt;RunInAction&lt;br&gt;Reaction &lt;/p&gt;
&lt;p&gt;调试&lt;/p&gt;
&lt;p&gt;toJs 需要引入 =&amp;gt; 不如直接 JSON.stringify()方便&lt;/p&gt;

      
    
    </summary>
    
      <category term="React" scheme="https://heiliu.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://heiliu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>classnames 的用法总结</title>
    <link href="https://heiliu.github.io/2019/10/13/classnames/"/>
    <id>https://heiliu.github.io/2019/10/13/classnames/</id>
    <published>2019-10-12T16:00:00.000Z</published>
    <updated>2019-11-06T10:22:06.962Z</updated>
    
    <content type="html"><![CDATA[<!-- TODO --><p><a href="https://github.com/JedWatson/classnames" target="_blank" rel="noopener">classnames github库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TODO --&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JedWatson/classnames&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;classnames github库&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VSCode 快捷键(持续更新)</title>
    <link href="https://heiliu.github.io/2019/10/13/VsCodeShortCuts/"/>
    <id>https://heiliu.github.io/2019/10/13/VsCodeShortCuts/</id>
    <published>2019-10-12T16:00:00.000Z</published>
    <updated>2019-11-06T11:03:40.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文档编辑中键盘快捷方式"><a href="#文档编辑中键盘快捷方式" class="headerlink" title="文档编辑中键盘快捷方式"></a>文档编辑中键盘快捷方式</h1><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li>快速移动光标（按单词跳: <strong>option <- -></-></strong> </li><li>行首行尾移动光标 : <strong>command <- -></-></strong></li><li>移动到文件头尾: <strong>commad <- -></-></strong> 上下方向键</li></ul><h2 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h2><ul><li>选中操作: <strong>shift <- -></-></strong> 方向键操作选中方向 </li><li>选中光标所在单词: <strong>command D</strong></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>搜索时切换搜索结果: <strong>shift Enter</strong> </li><li>文件相对路径: shift command H 原shortCut =&gt; 自定义 <strong>command H</strong> </li><li>新建未命名文件: command N  </li><li>搜索光标所在单词: command E </li><li>选中所在的代码块(select Bracket)，对花括号的代码块较友好: <strong>option command B</strong> </li><li>切换tab: <strong>option commmad <- -></-></strong> </li><li>删除整个单词: <strong>option backspace</strong></li><li>向上下复制整行: <strong>option shift <- -></-></strong> 上下方向键</li><li>找到当前文件所有与选中相同的文档 达到批量修改的目的(change all ocurrences): <strong>shift command I</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文档编辑中键盘快捷方式&quot;&gt;&lt;a href=&quot;#文档编辑中键盘快捷方式&quot; class=&quot;headerlink&quot; title=&quot;文档编辑中键盘快捷方式&quot;&gt;&lt;/a&gt;文档编辑中键盘快捷方式&lt;/h1&gt;&lt;h2 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="https://heiliu.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Note" scheme="https://heiliu.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://heiliu.github.io/2019/08/29/NginxGetStart/"/>
    <id>https://heiliu.github.io/2019/08/29/NginxGetStart/</id>
    <published>2019-08-29T10:14:41.350Z</published>
    <updated>2019-08-29T10:14:55.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.javaboy.org/2019/0605/nginx-guide.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.javaboy.org/2019/0605/nginx-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React-router V4</title>
    <link href="https://heiliu.github.io/2019/08/21/reactRouter/"/>
    <id>https://heiliu.github.io/2019/08/21/reactRouter/</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2019-11-06T10:21:06.801Z</updated>
    
    <content type="html"><![CDATA[<p>React 创建的单页应用中、通过路由来控制页面间的跳转，常用的就是 react-router、react-router-dom</p><h1 id="React-Router中有三类组件"><a href="#React-Router中有三类组件" class="headerlink" title="React Router中有三类组件"></a>React Router中有三类组件</h1><ul><li>路由组件 BrowserRouter, HashRouter  </li><li>路由匹配组件 Route, Switch  </li><li>导航、链接组件 Link</li></ul><blockquote><p>基于 React Router 的 web 应用，根组件应该是一个 router 组件（BrowserRouter，HashRouter ）。 项目中，react-router-dom 提供了和两种路由。两种路由都会创建一个 history 对象。如果我们的应用有服务器响应 web 的请求，我们通常使用<browserrouter>组件; 如果使用静态文件服务器，则我们应该使用<hashrouter>组件  通常都是使用 <browserrouter></browserrouter></hashrouter></browserrouter></p></blockquote><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Link 组件最终会渲染为 HTML 标签 <a>，它的 to、query、hash 属性会被组合在一起并渲染为 href 属性。虽然 Link 被渲染为超链接，但在内部实现上使用脚本拦截了浏览器的默认行为，然后调用了history.pushState 方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 创建的单页应用中、通过路由来控制页面间的跳转，常用的就是 react-router、react-router-dom&lt;/p&gt;
&lt;h1 id=&quot;React-Router中有三类组件&quot;&gt;&lt;a href=&quot;#React-Router中有三类组件&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="React" scheme="https://heiliu.github.io/categories/React/"/>
    
    
      <category term="React-router" scheme="https://heiliu.github.io/tags/React-router/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 相关</title>
    <link href="https://heiliu.github.io/2019/08/15/webpack/"/>
    <id>https://heiliu.github.io/2019/08/15/webpack/</id>
    <published>2019-08-15T09:37:21.189Z</published>
    <updated>2019-11-06T03:37:30.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="及时补"><a href="#及时补" class="headerlink" title="及时补"></a>及时补</h1><p>一篇篇都是欠下的债</p><p><a href="https://juejin.im/post/5cea1e1ae51d4510664d1652" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">官方文档传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;及时补&quot;&gt;&lt;a href=&quot;#及时补&quot; class=&quot;headerlink&quot; title=&quot;及时补&quot;&gt;&lt;/a&gt;及时补&lt;/h1&gt;&lt;p&gt;一篇篇都是欠下的债&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cea1e1ae51d45106
      
    
    </summary>
    
      <category term="前端" scheme="https://heiliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="webPack" scheme="https://heiliu.github.io/categories/%E5%89%8D%E7%AB%AF/webPack/"/>
    
    
      <category term="WebPack" scheme="https://heiliu.github.io/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习与整理</title>
    <link href="https://heiliu.github.io/2019/08/15/DesignPatterns/"/>
    <id>https://heiliu.github.io/2019/08/15/DesignPatterns/</id>
    <published>2019-08-15T06:22:55.389Z</published>
    <updated>2019-11-06T11:15:53.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://heiliu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Note" scheme="https://heiliu.github.io/tags/Note/"/>
    
      <category term="设计模式" scheme="https://heiliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Skill" scheme="https://heiliu.github.io/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>Axios</title>
    <link href="https://heiliu.github.io/2019/08/15/Axios/"/>
    <id>https://heiliu.github.io/2019/08/15/Axios/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-11-06T03:29:53.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先从fetch讲起"><a href="#先从fetch讲起" class="headerlink" title="先从fetch讲起"></a>先从fetch讲起</h2><p>一个简单的fetch例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'./api/person.json'</span>)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.status !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Looks like there was a problem. Status Code: '</span> +</span><br><span class="line">          response.status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Examine the text in the response</span></span><br><span class="line">      <span class="comment">// 将返回数据 Json 化</span></span><br><span class="line">      response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Fetch Error :-S'</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="number">1.</span> .json()返回一个被解析为<span class="built_in">JSON</span>格式的<span class="string">`promise`</span>对象，当获取成功时，我们使用 json() 读取并解析数据</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用async-await简化"><a href="#使用async-await简化" class="headerlink" title="使用async/await简化"></a>使用async/await简化</h3><p>由于Fetch底层是用Promise实现，我们可以直接用async来优化上面的代码，减少回调，使其更加语义化、容易理解， 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">geturl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">'./api/some.json'</span>)</span><br><span class="line"><span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> res.text())</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// response 其他返回数据</span></span><br><span class="line">fetch(<span class="string">'users.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers.get(<span class="string">'Content-Type'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers.get(<span class="string">'Date'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.type);</span><br><span class="line">    <span class="built_in">console</span>.log(response.url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Response-类型"><a href="#Response-类型" class="headerlink" title="Response 类型"></a>Response 类型</h4><p>当我们发起一个Fetch请求时，返回的response响应会自带一个response.type属性（basic、cors、opaque）。response.type属性说明了异步资源的来源，同时还有相应的处理方式。<br>当我们发起一个同源请求时，response.type为basic，而且你可以从response读取全部信息。<br>如果我们访问一个非同源域名，并且有返回相应的CORs响应头时，那么该请求类型是cors。  cors和basic很相似，就除了cors响应里你无法访问Cache-Control，Content-Language，Content-Type，Expires，Last-Modified和Pragma<br>当我们对一个不同源的域名发起请求时，如果返回的响应头部没有CORS信息，那么这个response对应的类型就是opaque类型。一个opaque响应是无法读取返回的数据、状态，甚至无法确定这个请求是否成功。<br>我们可以自定义Fetch请求的模式，要求返回对应类型的响应，有以下几种响应：</p><ul><li>1.same-origin 只返回同源请求，其他类型会被reject  </li><li>2.cors 接收同源、非同源请求，返回有CORs头部的响应  </li><li>3.cors-with-forced-preflight 在发出请求前会先做一次安全性检查  </li><li>4.no-cors 用来发起没有CORS头部并且非同源请求，并且会返回opaque响应。但是目前这种类型只能在Service Worker里使用，在window.fetch里不能用  </li></ul><h3 id="POST请求类型"><a href="#POST请求类型" class="headerlink" title="POST请求类型"></a>POST请求类型</h3><p>使用Fetch发起Post请求时，需要手动设置method参数和body参数，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">"Content-type"</span>: <span class="string">"application/x-www-form-urlencoded; charset=UTF-8"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    body: <span class="string">'foo=bar&amp;lorem=ipsum'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(json)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request failed'</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="带-COOKIE-发送请求"><a href="#带-COOKIE-发送请求" class="headerlink" title="带 COOKIE 发送请求"></a>带 COOKIE 发送请求</h3><p>在异步请求中带上cookie参数，那么需要显式指定credentials参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">  credentials: <span class="string">'include'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>从浏览器中创建 XMLHttpRequests  </li><li>从 node.js 创建 http 请求  </li><li>支持 Promise API  </li><li>拦截请求和响应  </li><li>转换请求数据和响应数据  </li><li>取消请求  </li><li>自动转换 JSON 数据  </li><li>客户端支持防御 XSRF  </li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm 安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure></p><p>使用cdn:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>响应返回包含信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">文档传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先从fetch讲起&quot;&gt;&lt;a href=&quot;#先从fetch讲起&quot; class=&quot;headerlink&quot; title=&quot;先从fetch讲起&quot;&gt;&lt;/a&gt;先从fetch讲起&lt;/h2&gt;&lt;p&gt;一个简单的fetch例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;./api/person.json&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .then(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (response.status !== &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Looks like there was a problem. Status Code: &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          response.status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Examine the text in the response&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将返回数据 Json 化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      response.json().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Fetch Error :-S&#39;&lt;/span&gt;, err);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; .json()返回一个被解析为&lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;格式的&lt;span class=&quot;string&quot;&gt;`promise`&lt;/span&gt;对象，当获取成功时，我们使用 json() 读取并解析数据&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Skill" scheme="https://heiliu.github.io/categories/Skill/"/>
    
      <category term="JavaScript" scheme="https://heiliu.github.io/categories/Skill/JavaScript/"/>
    
    
      <category term="前端" scheme="https://heiliu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>E2E 测试</title>
    <link href="https://heiliu.github.io/2019/08/14/E2ETest/"/>
    <id>https://heiliu.github.io/2019/08/14/E2ETest/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-11-06T10:21:45.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><a href="https://segmentfault.com/a/1190000015724775" target="_blank" rel="noopener">参考链接</a>  </p><h2 id="小程序自动化"><a href="#小程序自动化" class="headerlink" title="小程序自动化"></a>小程序自动化</h2><p>小程序自动化SDK为开发者提供了一套通过外部脚本操控小程序的方案，从而实现小程序自动化测试的目的。  </p><p>通过该 SDK，你可以做到以下事情：</p><ul><li>控制小程序跳转到指定页面  </li><li>获取小程序页面数据  </li><li>获取小程序页面元素状态  </li><li>触发小程序元素绑定事件  </li><li>往 AppService 注入代码片段  </li><li>调用 wx 对象上任意接口  </li></ul><p>安装小程序自动化SDK：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install miniprogram-automator --save-dev</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015724775&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="Test" scheme="https://heiliu.github.io/categories/Test/"/>
    
    
      <category term="Test" scheme="https://heiliu.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>去除 inline 元素之间的间距</title>
    <link href="https://heiliu.github.io/2019/08/13/spaceBetweenInlineBlock/"/>
    <id>https://heiliu.github.io/2019/08/13/spaceBetweenInlineBlock/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-10-13T09:30:57.217Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题曾经在哪一次的面试中被问到过，当时只知道是空白的文本节点在作祟，但是问到解决的方法，却没有答上来，今天在项目里碰到了详细了解了一下，记录一下。  </p><!-- TODO --><p><a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="noopener">详情参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个问题曾经在哪一次的面试中被问到过，当时只知道是空白的文本节点在作祟，但是问到解决的方法，却没有答上来，今天在项目里碰到了详细了解了一下，记录一下。  &lt;/p&gt;
&lt;!-- TODO --&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhangxinxu.com/wo
      
    
    </summary>
    
      <category term="面试" scheme="https://heiliu.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://heiliu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="https://heiliu.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://heiliu.github.io/2019/08/12/setPerformance/"/>
    <id>https://heiliu.github.io/2019/08/12/setPerformance/</id>
    <published>2019-08-12T03:48:34.349Z</published>
    <updated>2019-11-06T10:50:21.217Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 利用set提高性能<br>tags: JavaScript<br>categories:</p><ul><li>前端</li><li>JavaScript</li></ul><hr><!-- TODO --><p>经过实际比较来说，如何减少重绘和回流比选择数组还是Set来操作数据对于前端性能而言更为重要</p><p><a href="https://juejin.im/post/5d2284dc51882579df4a4cee" target="_blank" rel="noopener">详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 利用set提高性能&lt;br&gt;tags: JavaScript&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;!-- TODO --&gt;
&lt;p&gt;经过实际比较来说，如何
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://heiliu.github.io/2019/08/05/Array/"/>
    <id>https://heiliu.github.io/2019/08/05/Array/</id>
    <published>2019-08-04T23:42:00.000Z</published>
    <updated>2019-11-06T10:22:48.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>一个存储元素的线性集合， 元素可以通过索引（通常为数字）来任意存取。  </p></blockquote><p>数字索引在内部被转换为字符串类型、这是因为在javaScript中对象的属性名必须是字符串。而数组只是一种特殊的对象</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul><li><p>通过<code>构造函数</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 传入一组元素进行数组初始化 --&gt;</span><br><span class="line"><span class="keyword">var</span> arr = New <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">print(arr.length); <span class="comment">// 5</span></span><br><span class="line">&lt;!-- 只传一个元素，声明数组的初始化长度, 其中每个元素初始化为 <span class="literal">undefined</span> --&gt;</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">print(arr1.length); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>通过字面量 <code>[]</code> 创建  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">print(arr2.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>区别<br>虽然两种创建数组的方法产生的效果一样，但是还是存在一些细微的差别。而且你会发现，在JS开源库中，通过第一种方法来创建数组基本上看不到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'using[]'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">2000000</span>; i++)&#123;<span class="keyword">var</span> arr = []&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'using[]'</span>)  <span class="comment">// using[]: 29.630859375ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'using new'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">2000000</span>; i++)&#123;<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'using new'</span>)  <span class="comment">// using new: 39.93798828125ms</span></span><br></pre></td></tr></table></figure><p>通过对比会发现使用new关键字来创建数组花费的时间更长，<code>实际上</code>使用new来创建会多一个实例化的过程，在Javascript里分配大量的new变量地址是一项很慢的操作，为了效率起见，你应该始终使用对象符号。虽然<code>只有在大批量数据的情况下才会有影响</code>.</p><p>创建一个字符串的方式有：‘字符串’或者是new String(‘字符串’)，一种是直接创建了一个字符串，一个是调用字符串的构造函数创建字符串对象然后再创建这个字符串，中间多了一个创建对象的过程，也许这在一般情况下是看不出什么区别的，但是像上述例子中，当数据足够大的时候，就会发现了问题所在。因此，如果可以通过[]创建一个纯净的数组，就不需要通过new Array()来创建数组。</p></li></ul><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>isArray </p><p>存取函数  </p><blockquote><p>用来访问数组元素的函数，返回目标数组的某种变体  </p></blockquote><p>indexOf() 返回第一个与参数相同的元素的索引, 不存在返回 -1</p><p>lastIndexOf 返回相同元素中最后一个元素的索引,不存在返回 -1</p><p>数组的字符串表示  </p><p>join()</p><p>toString()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">"David"</span>,<span class="string">"Cynthia"</span>,<span class="string">"Raymond"</span>,<span class="string">"Clayton"</span>,<span class="string">"Mike"</span>,<span class="string">"Jennifer"</span>];</span><br><span class="line"><span class="keyword">var</span> namestr = names.join();</span><br><span class="line">print(namestr); <span class="comment">// David,Cynthia,Raymond,Clayton,Mike,Jennifer</span></span><br><span class="line">namestr = names.toString();</span><br><span class="line">print(namestr); <span class="comment">// David,Cynthia,Raymond,Clayton,Mike,Jennifer</span></span><br></pre></td></tr></table></figure><p>由已有数组创建新的数组  </p><p>concat()  合并多个数组创建一个新数组<br>splice()  截取一个数组的子集创建一个新数组<br>slice() </p><p>使用 splice() 方法为数组添加元素，需提供如下参数：<br>• 起始索引（也就是你希望开始添加元素的地方）；<br>• 需要删除的元素个数（<code>添加元素时该参数设为 0</code>）；<br>• 想要添加进数组的元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> newElements = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">nums.splice(<span class="number">3</span>,<span class="number">0</span>,newElements);</span><br><span class="line">print(nums); <span class="comment">// 1,2,3,4,5,6,7,8,9</span></span><br></pre></td></tr></table></figure></p><p>可变函数  </p><blockquote><p>能够改变数组的内容的函数  </p></blockquote><p>push() 在末尾添加元素<br>pop() 删除末尾的元素</p><p>shift()<br>unshift() 添加元素到数组的开头</p><p>reverse() 翻转数组<br>sort()<br>对数组进行排序是经常会遇到的需求，如果元素是字符串类型，那么sort() 就非常好使：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">"David"</span>,<span class="string">"Mike"</span>,<span class="string">"Cynthia"</span>,<span class="string">"Clayton"</span>,<span class="string">"Bryan"</span>,<span class="string">"Raymond"</span>];</span><br><span class="line">names.sort();</span><br><span class="line">print(names); <span class="comment">// Bryan,Clayton,Cynthia,David,Mike,Raymond</span></span><br></pre></td></tr></table></figure></p><p>但是如果数组元素是数字类型，sort() 方法的排序结果就不能让人满意了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>];nums.sort();print(nums); <span class="comment">// 1,100,2,200,3,4sort()</span></span><br></pre></td></tr></table></figure></p><p>方法是按照<code>字典顺序</code>对元素进行排序的，因此它 <code>假定元素都是字符串类型</code>，在上一个例子中，即使元素是数字类型，也被认为是字符串类型。为了让 sort() 方法也能排序数字类型的元素，可以在调用方法时传入一个大小比较函数，排序时，sort() 方法将会根据该函数比较数组中两个元素的大小，从而决定整个数组的顺序。<br><code>对于数字类型，该函数可以是一个简单的相减操作，从一个数字中减去另外一个数字。如果结果为负，那么被减数小于减数；如果结果为 0，那么被减数与减数相等；如果结果为正，那么被减数大于减数。</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>];</span><br><span class="line">nums.sort(compare);print(nums); <span class="comment">// 1,2,3,4,100,200</span></span><br></pre></td></tr></table></figure></p><p>sort() 函数使用了 compare() 函数对数组按照数字大小进行排序，而不是按照字典顺序。</p><p>迭代器方法  </p><p>其实可以多展开来讲的 map foreach filter reduce 的区别</p><ul><li>forEach()  </li><li>every()  </li><li>some()  </li><li>map()  </li><li>filter()  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=&quot;定义：&quot;&gt;&lt;/a&gt;定义：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个存储元素的线性集合， 元素可以通过索引（通常为数字）来任意存取。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数字索引在内部被转换为字符串类型、这是因为在javaScript中对象的属性名必须是字符串。而数组只是一种特殊的对象&lt;/p&gt;
&lt;h3 id=&quot;创建数组&quot;&gt;&lt;a href=&quot;#创建数组&quot; class=&quot;headerlink&quot; title=&quot;创建数组&quot;&gt;&lt;/a&gt;创建数组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;构造函数&lt;/code&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 传入一组元素进行数组初始化 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = New &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(arr.length); &lt;span class=&quot;comment&quot;&gt;// 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 只传一个元素，声明数组的初始化长度, 其中每个元素初始化为 &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt; --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(arr1.length); &lt;span class=&quot;comment&quot;&gt;// 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="https://heiliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Note" scheme="https://heiliu.github.io/tags/Note/"/>
    
      <category term="JavaScript" scheme="https://heiliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>同一台电脑配置多个SSH</title>
    <link href="https://heiliu.github.io/2019/07/31/multiSSH/"/>
    <id>https://heiliu.github.io/2019/07/31/multiSSH/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-11-06T10:17:34.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置多个SSH"><a href="#配置多个SSH" class="headerlink" title="配置多个SSH"></a>配置多个SSH</h2><p>在工作中多访问公司的gitlab仓库，而在生活中又有自己的github仓库<br>记录一下方便日后查找</p><hr><p>一般电脑中的SSH key 存放在 <code>～/.ssh</code>目录中 如果有配置过的话存在 <code>id_rsa</code> \ <code>id_rsa.pub</code> 私钥和公钥, 将公钥配置到需要的代码平台</p><p>生成SSH key</p><h3 id="本地配置多个ssh-key"><a href="#本地配置多个ssh-key" class="headerlink" title="本地配置多个ssh key"></a>本地配置多个ssh key</h3><ul><li><p>1、为公司生成一对秘钥ssh key  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'yourEmail@xx.com'</span> -f ~<span class="regexp">/.ssh/gi</span>tlab_id_rsa</span><br></pre></td></tr></table></figure></li><li><p>2、为github生成一对秘钥ssh key  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'yourEmail2@xx.com'</span> -f ~<span class="regexp">/.ssh/gi</span>thub_id_rsa</span><br></pre></td></tr></table></figure></li><li><p>3、在~/.ssh目录下新建名称为<code>config</code>的文件（无后缀名）。  用于配置多个不同的host使用不同的ssh key，常用内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># gitlab</span><br><span class="line">Host gitlab.planetmeican.com</span><br><span class="line">    HostName gitlab.planetmeican.com</span><br><span class="line">    Port <span class="number">2345</span></span><br><span class="line">    User git</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~<span class="regexp">/.ssh/gi</span>tlab_id_rsa</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~<span class="regexp">/.ssh/gi</span>thub_id_rsa</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置文件参数"><a href="#配置文件参数" class="headerlink" title="配置文件参数"></a>配置文件参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件</span><br><span class="line"># port: 端口号，一般不需要配置</span><br><span class="line"># HostName : 要登录主机的主机名</span><br><span class="line">#PreferredAuthentications: 授权验证方式</span><br><span class="line"># User : 登录名</span><br><span class="line"># IdentityFile : 指明上面User对应的identityFile路径</span><br></pre></td></tr></table></figure><ul><li>4、分别往gitlab和github上添加生成的公钥</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置多个SSH&quot;&gt;&lt;a href=&quot;#配置多个SSH&quot; class=&quot;headerlink&quot; title=&quot;配置多个SSH&quot;&gt;&lt;/a&gt;配置多个SSH&lt;/h2&gt;&lt;p&gt;在工作中多访问公司的gitlab仓库，而在生活中又有自己的github仓库&lt;br&gt;记录一下方便日后查
      
    
    </summary>
    
      <category term="倒腾" scheme="https://heiliu.github.io/categories/%E5%80%92%E8%85%BE/"/>
    
      <category term="Note" scheme="https://heiliu.github.io/categories/%E5%80%92%E8%85%BE/Note/"/>
    
      <category term="Git" scheme="https://heiliu.github.io/categories/%E5%80%92%E8%85%BE/Note/Git/"/>
    
    
      <category term="Git" scheme="https://heiliu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>serverless了解</title>
    <link href="https://heiliu.github.io/2019/07/29/serverless/"/>
    <id>https://heiliu.github.io/2019/07/29/serverless/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-11-06T10:19:58.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="serverless"><a href="#serverless" class="headerlink" title="serverless"></a>serverless</h1><blockquote><p>根据 CNCF 的定义，Serverless 是指构建和运行不需要服务器管理的应用程序的概念。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;serverless&quot;&gt;&lt;a href=&quot;#serverless&quot; class=&quot;headerlink&quot; title=&quot;serverless&quot;&gt;&lt;/a&gt;serverless&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;根据 CNCF 的定义，Serverless 是指
      
    
    </summary>
    
      <category term="server" scheme="https://heiliu.github.io/categories/server/"/>
    
    
      <category term="Skill" scheme="https://heiliu.github.io/tags/Skill/"/>
    
      <category term="倒腾" scheme="https://heiliu.github.io/tags/%E5%80%92%E8%85%BE/"/>
    
  </entry>
  
</feed>
